#!perl
use 5.20.0;
package Synergy;
use Moses;
use namespace::autoclean;

use experimental 'postderef';

use DateTime::Format::Natural;
use HTTP::Body;
use JSON 2 ();
use MIME::Base64;
use Path::Tiny;
use POE::Component::Server::SimpleHTTP;
use Time::Duration::Parse;
use Time::Duration;
use YAML::XS;
use IO::Async::Loop::POE;
use Net::Async::HTTP;
use URI;
use Lingua::EN::Inflect qw(PL_N);

use Synergy::User;

my $JSON = JSON->new;

my $cname = 'SYNERGY_CONFIG';

die "You must set \$$cname to the Synergy config file.\n"
  unless defined $ENV{$cname};

die "Config file '$ENV{$cname}' not found" unless -e $ENV{$cname};

my $config = YAML::XS::LoadFile($ENV{SYNERGY_CONFIG});

flood    1;
server   $config->{irc}{server};
nickname $config->{irc}{nickname};
username $config->{irc}{username};
channels(values %{ $config->{irc}{channels} });
password $config->{irc}{password};
poco_irc_args(UseSSL => 1);

my $WKSP_ID = $config->{liquidplanner}{workspace};
my $LP_BASE = "https://app.liquidplanner.com/api/workspaces/$WKSP_ID";
my $LINK_BASE = "https://app.liquidplanner.com/space/$WKSP_ID/projects/show/";
my $CIRC_BASE = "https://api.circonus.com";

has io_loop => (
  is => 'ro',
  isa => 'IO::Async::Loop::POE',
  default => sub { IO::Async::Loop::POE->new() },
);

has http => (
  is => 'ro',
  isa => 'Net::Async::HTTP',
  lazy => 1,
  default => sub {
    my $http = Net::Async::HTTP->new(
      max_connections_per_host => 5, # seems good?
    );

    shift->io_loop->add($http);

    return $http;
  },
);

has users => (
  isa  => 'HashRef',
  lazy => 1,
  traits  => [ 'Hash' ],
  handles => {
    users      => 'values',
    user_named => 'get',
    usernames  => 'keys',
  },
  clearer => '_clear_users',
  default => sub {
    my %uconf = %{ $config->{users} };
    my %users
      = map {; $_ => Synergy::User->new({ username => $_, %{ $uconf{$_} } }) }
        keys %uconf;
    return \%users;
  },
);

sub phone_for_username {
  my ($self, $username) = @_;
  return unless my $user = $self->user_named($username);
  return $user->phone;
}

sub lp_id_for_username {
  my ($self, $username) = @_;
  return unless my $user = $self->user_named($username);
  return $user->lp_id;
}

sub want_page_for_username {
  my ($self, $username) = @_;
  return unless my $user = $self->user_named($username);
  return $user->want_page;
}

sub username_for_phone {
  my ($self, $phone) = @_;
  my ($user) = grep { $_->has_phone && $_->phone eq $phone } $self->users;
  return $user;
}

sub user_for_circonus_id {
  my ($self, $id) = @_;
  my ($user) = grep { $_->has_circonus_id && $_->circonus_id eq $id } $self->users;
  return $user;
}

has _recent_alerts => (
  is  => 'ro',
  default => sub {  {}  },
);

sub recent_alerts {
  my ($self) = @_;
  my $stash = $self->_recent_alerts;
  my $now = time;
  for my $key (keys %$stash) {
    delete $stash->{$key} if $now - $stash->{$key}{recorded_at} > 15*60;
  }

  return $stash;
}

sub record_alerts {
  my ($self, $alerts) = @_;

  my $now   = time;
  my $stash = $self->recent_alerts;

  for my $alert (@$alerts) {
    $stash->{ $alert->{alert_id} } = {
      recorded_at => $now,
      metric_name => $alert->{metric_name},
      host        => $alert->{host},
      check_id    => $alert->{check_id},
    };
  }

  return;
}

has suppress_alerts_until => (
  is  => 'rw',
  isa => 'Int',
  predicate => 'has_suppress_alerts_until',
  clearer   => 'clear_suppress_alerts_until',
);

has httpd => (
  is => 'bare',
  builder => '_build_httpd',
);

has httpd_port => (is => 'ro', lazy => 1, default => 8118);

sub resolve_name {
  my ($self, $name, $who) = @_;

  return unless $name;

  $name = lc $name;
  $name = $who if $name eq 'me' || $name eq 'my' || $name eq 'myself' || $name eq 'i';

  my $user = $self->user_named($name);
  unless ($user) {
    ($user) = grep {; grep { $_ eq $name } $_->nicknames } $self->users;
  }

  return $user;
}

sub START {
  my ($self, $kernel) = @_[ OBJECT, KERNEL ];
  $kernel->alias_set('Synergy');
}

sub _build_httpd {
  my ($self) = @_;
  my $session_id = $self->get_session_id;

  POE::Component::Server::SimpleHTTP->new(
    ALIAS   => 'httpd',
    ADDRESS => 0,
    PORT    => $self->httpd_port,
    HANDLERS => [
      {
        DIR => '^/sms$',
        SESSION => 'Synergy',
        EVENT => '_http_sms',
      },
      {
        DIR => '^/alert.json$',
        SESSION => 'Synergy',
        EVENT => '_http_alert',
      },
      {
        DIR => '.*',
        SESSION => 'Synergy',
        EVENT => '_http_404',
      },
    ],
    HEADERS => { Server => 'Synergy' },
  );
}

event _http_alert => sub {
  my ($kernel, $self, $request, $response) = @_[ KERNEL, OBJECT, ARG0 .. ARG1 ];

  # Check for errors
  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  my @msgs;

  my $json = $request->content;
  warn "CIRCONUS: $json\n";
  # {
  #   "alerts": [
  #     {"check_name":"pb-wm1.int.icgroup.com basic","metric_link":null,"check_id":96848,"alert_value":null,"check_bundle_id":73559,"alert_url":"https://circonus.com/account/ic-group-inc/fault-detection?alert_id=19039695","host":"pb-wm1.int.icgroup.com","metric_notes":null,"alert_time":"Sun, 22 Mar 2015 20:01:02","clear_time":"Sun, 22 Mar 2015 20:07:22","metric_name":"service|-faults","clear_value":"0.0","agent":"Quonix","severity":"1","alert_id":"19039695"}
  #   ],
  #   "account_name":"IC Group, INC"
  # }

  my $data = eval { $JSON->decode($json); };

  if ($data) {
    for my $alert (@{ $data->{alerts} }) {
      push @msgs, $self->_fmt_alert($alert);
    }
  } else {
    @msgs = ("Error decoding <$json>: $@");
  }

  $kernel->call( 'httpd', 'DONE', $response );

  $response->code(204);

  if ($self->has_suppress_alerts_until && time < $self->suppress_alerts_until) {
    $self->info("Declining to relay alerts during suppression period.");
  } else {
    # We only record the alerts when we mention them, because otherwise it
    # might be weird to see no alerts, then "ack all those" doing something.
    # -- rjbs, 2015-03-23
    $self->record_alerts($data->{alerts});
    for my $msg (@msgs) {
      $self->privmsg(
        $config->{irc}{channels}{alerts},
        $msg,
      );
    }
  }

  $self->info(
    sprintf "Request from %s: %s %s",
      $response->connection->remote_ip,
      $request->method,
      $request->uri->path_query
  );
};

sub _fmt_alert {
  my ($self, $alert) = @_;

  my $type   = $alert->{clear_time} ? 'recovery' : 'alert';
  $type .= "-$alert->{severity}" unless $alert->{clear_time};

  my $metric = $alert->{metric_name}
             . ($alert->{metric_notes} ? " ($alert->{metric_notes})" : '');

  sprintf 'Circonus alert %u: [%s] %s / %s <%s>',
    $alert->{alert_id},
    uc $type,
    $alert->{check_name},
    $metric,
    $alert->{alert_url};
}

sub _params_from_req {
  my ($self, $req) = @_;

  my $body = HTTP::Body->new(
    scalar $req->header('Content-Type'),
    scalar $req->header('Content-Length'),
  );
  $body->add( $req->content );

  return $body->param;
}

event _http_sms => sub {
  my ($kernel, $self, $request, $response, $dirmatch)
    = @_[ KERNEL, OBJECT, ARG0 .. ARG2 ];

  # Check for errors
  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  my $param = $self->_params_from_req($request);

  my $from = $param->{From} // '';
  $from =~ s/\A\+1//;

  my $who = $self->username_for_phone($from);
  unless ($param->{AccountSid} eq $config->{twilio}{sid} and $who) {
    $response->code(400);
    $response->content("Bad request");
    $kernel->call( 'httpd', 'DONE', $response );
    $self->info(sprintf "Bad request for %s from phone %s from IP %s",
      $request->uri->path_query,
      $from,
      $response->connection->remote_ip,
    );
    return;
  }

  my $text = $param->{Body};

  my $reply = q{};
  my $result = $self->_dispatch({
    how   => 'sms',
    who   => $who->username,
    where => [ $from ],
    what  => $text,
    reply_buffer => \$reply,
  });

  if ($result && $result eq -1) {
    $response->code(200);
    $response->content( $self->_does_not_compute($who) );
  } else {
    $response->code(200);
    $response->content($reply);
  }

  $kernel->call( 'httpd', 'DONE', $response );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub __pick_one {
  my ($opts) = @_;
  return $opts->[ rand @$opts ];
}

sub _does_not_compute {
  my ($self, $user) = @_;

  my @replies = $user ? $user->wtf_replies : ();
  @replies = 'Does not compute.' unless @replies;
  return __pick_one(\@replies);
}

sub SAID_eject {
  my ($self, $arg) = @_;
  return -1 unless $arg->{what} eq 'warp core';
  kill 'INT', $$;
}

sub SAID_announce {
  my ($self, $arg) = @_;

  if ($arg->{how} eq 'irc') {
    return $self->reply(
      "Asking me to say something on IRC when you're on IRC is weird.",
      $arg,
    );
  }

  my $what = $arg->{what} =~ s/\Athat:? //r;

  $self->privmsg(
    $config->{irc}{channels}{general},
    "$arg->{who} says: $what",
  );

  $self->reply("Message relayed", $arg);
}

event _http_404 => sub {
  my ($kernel, $self, $request, $response) = @_[ KERNEL, OBJECT, ARG0 .. ARG2 ];

  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  # Do our stuff to HTTP::Response
  $response->code(404);
  $response->content( "Hi visitor from " . $response->connection->remote_ip . ", Page not found -> '" . $request->uri->path . "'\n\n" );

  # We are done!
  # For speed, you could use $_[KERNEL]->call( ... )
  $kernel->call( 'httpd', 'DONE', $response );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub __hs { $_[0] * 3600 + $_[1] * 60 }

sub sms {
  my ($self, $number, $msg) = @_;

  my $res = $self->http_post(
    "https://api.twilio.com/2010-04-01/Accounts/$config->{twilio}{sid}/SMS/Messages",
    {
      From => $config->{twilio}{from},
      To   => $number,
      Body => $msg,
    },
    Authorization => "Basic $config->{twilio}{auth}",
  );
}

event nag => sub {
  my ($self) = $_[OBJECT];

  $self->info("considering nagging and setting up next nag");

  $self->delay(nag => 300);

  USER: for my $user ($self->users) {
    next USER unless my $sy_timer = $user->timer;
    next USER unless $user->should_nag;
    my $username = $user->username;

    my $last_nag = $sy_timer->last_relevant_nag;
    my $lp_timer = $self->lp_timer_for_user($user);

    if ($lp_timer && $lp_timer == -1) {
      warn "$username: error retrieving timer\n";
      next USER;
    }

    # Record the last time we saw a timer
    if ($lp_timer) {
      $sy_timer->last_saw_timer(time);
    }

    { # Timer running too long!
      if ($lp_timer && $lp_timer->{running_time} > 3) {
        if ($last_nag && time - $last_nag->{time} < 900) {
          $self->info("$username: Won't nag, nagged within the last 15min.");
          next USER;
        }

        my $msg = "Your timer has been running for "
                . concise(duration($lp_timer->{running_time} * 3600))
                . ".  Maybe you should commit your work.";

        $self->privmsg($user->username, $msg);
        $self->sms($user->phone, $msg) if $user->has_phone;

        $sy_timer->last_nag({ time => time, level => 0 });
        next USER;
      }
    }

    if ($sy_timer->is_showtime) {
      if ($lp_timer) {
        $self->info("$username: We're good: there's a timer.");

        $sy_timer->clear_last_nag;
        next USER;
      }

      my $level = 0;
      if ($last_nag) {
        if (time - $last_nag->{time} < 900) {
          $self->info("$username: Won't nag, nagged within the last 15min.");
          next USER;
        }
        $level = $last_nag->{level} + 1;
      }

      # Have we seen a timer recently? Give them a grace period
      if (
           $sy_timer->last_saw_timer
        && $sy_timer->last_saw_timer > time - ($config->{nag_grace_period} || 900)
      ) {
        warn("$username: Not nagging, they only recently disabled a timer");
        next USER;
      }

      my $still = $level == 0 ? '' : ' still';
      my $msg   = "Your LiquidPlanner timer$still isn't running";
      $self->privmsg($user->username, $msg);
      if ($level >= 2 && $user->has_phone) {
        $self->sms($user->phone, $msg);
      }
      $sy_timer->last_nag({ time => time, level => $level });
    }
  }
};

sub lp_timer_for_user {
  my ($self, $user) = @_;

  return unless $user->lp_auth_header;

  my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");
  return -1 unless $res->is_success;

  my ($timer) = grep {; $_->{running} }
                @{ $JSON->decode( $res->decoded_content ) };

  return $timer;
}

sub http_get_for_user {
  my $self = shift;
  my $user = shift;

  return $self->http_get(@_,
    Authorization => $user->lp_auth_header,
  );
}

sub http_post_for_user {
  my $self = shift;
  my $user = shift;

  return $self->http_post(@_,
    Authorization => $user->lp_auth_header,
  );
}

sub circ_get {
  my $self = shift;

  my $token = $config->{circonus}{token};

  return $self->http_get(@_,
    'X-Circonus-App-Name' => 'Synergy',
    'X-Circonus-Auth-Token' => $token,
    'Accept' => "application/json",
  );
}

sub circ_post {
  my $self = shift;

  my $token = $config->{circonus}{token};

  return $self->http_post(@_,
    'X-Circonus-App-Name' => 'Synergy',
    'X-Circonus-Auth-Token' => $token,
    'Accept' => "application/json",
  );
}

sub circ_put {
  my $self = shift;

  my $token = $config->{circonus}{token};

  return $self->http_put(@_,
    'X-Circonus-App-Name' => 'Synergy',
    'X-Circonus-Auth-Token' => $token,
    'Accept' => "application/json",
  );
}

sub http_get {
  return shift->http_request('GET' => @_);
}

sub http_post {
  return shift->http_request('POST' => @_);
}

sub http_put {
  return shift->http_request('PUT' => @_);
}

sub http_request {
  my ($self, $method, $url, %args) = @_;

  my $content = delete $args{Content};
  my $content_type = delete $args{Content_Type};

  my @args = $url;

  if ($method ne 'GET' && $method ne 'HEAD') {
    push @args, $content // [];
  }

  if ($content_type) {
    push @args, content_type => $content_type;
  }

  push @args, headers => \%args;

  # The returned future will run the loop for us until we return. This makes
  # it asynchronous as far as the rest of the code is concerned, but
  # sychronous as far as the caller is concerned.
  return $self->http->$method(
    @args
  )->on_fail( sub {
    my $failure = shift;
    warn "Failed to $method $url: $failure\n";
  } )->get;
}

sub lp_tasks_for_user {
  my ($self, $user, $count, $arg) = @_;

  return unless $user && $user->lp_auth_header;

  my $res = $self->http_get_for_user(
    $user,
    "$LP_BASE/upcoming_tasks?limit=200&flat=true&member_id=" . $user->lp_id,
  );

  unless ($res->is_success) {
    warn "failed to get tasks from LiquidPlanner: " . $res->as_string;
    return;
  }

  my $tasks = $JSON->decode( $res->decoded_content );

  if ($arg->{inbox}) {
    @$tasks = grep {;
      (grep { $config->{liquidplanner}{inbox} == $_ } $_->{parent_ids}->@*)
      ||
      (grep { $config->{liquidplanner}{inbox} == $_ } $_->{package_ids}->@*)
    } @$tasks;
  } else {
    @$tasks = grep {;
      (! grep { $config->{liquidplanner}{inbox} == $_ } $_->{parent_ids}->@*)
      &&
      (! grep { $config->{liquidplanner}{inbox} == $_ } $_->{package_ids}->@*)
    } @$tasks;
  }

  splice @$tasks, $count;

  my $urgent = $config->{liquidplanner}{urgent};
  for (@$tasks) {
    $_->{name} = "[URGENT] $_->{name}"
      if (grep { $urgent == $_ } $_->{parent_ids}->@*)
      || (grep { $urgent == $_ } $_->{package_ids}->@*);
  }

  return $tasks;
}

sub _lp_task_is_unestimated {
  my ($self, $task) = @_;

  # A task can be estimated to have 0 remaining effort. If so
  # it will have an expect_start and expect_finish.
  return    $task->{low_effort_remaining} == 0
         && $task->{high_effort_remaining} == 0
         && ! $task->{expected_start}
         && ! $task->{expected_finish};
}

sub lp_damage_report {
  my ($self, $user, $lp_id) = @_;

  return unless $user && $user->lp_auth_header;

  $lp_id //= $user->lp_id;

  my $res = $self->http_get_for_user(
    $user,
    "$LP_BASE/upcoming_tasks?limit=200&member_id=" . $lp_id,
  );

  unless ($res->is_success) {
    warn "failed to get tasks from LiquidPlanner: " . $res->as_string;
    return;
  }

  my $groups = $JSON->decode( $res->decoded_content );
  return "no upcoming work... what??" unless @$groups;

  my $summary = q{};
  splice @$groups, 4;
  while (my $group = shift @$groups) {
    next unless $group->{items}->@*;

    my $count = 0;
    my $unest = 0;
    for my $item ($group->{items}->@*) {
      # upcoming_tasks is meant to act like My Work, in which on-hold tasks are
      # not shown, but it includes on hold tasks.  bug filed
      next if $item->{is_on_hold};

      # Project, parent, and package are a complete mess, or at least mystery,
      # in the LiquidPlanner API.  Here, I'm trying to exclude tasks that are
      # in a project but not a package, meaning they're basically backlog work.
      next if $item->{project_id} && ! $item->{package_id};

      $count++;
      my ($assignment) = grep {; $_->{person_id} == $lp_id }
                         $item->{assignments}->@*;

      $unest++ if $self->_lp_task_is_unestimated($assignment);
    }

    $summary .= $group->{group} eq 'INBOX'
              ? 'inbox'
              : "week of $group->{from}";

    $summary .= sprintf ": %u %s", $count, PL_N('item', $count);
    $summary .= sprintf ", %u unestimated", $unest if $unest;
    $summary .= "; " if @$groups;
  }

  return $summary;
}

sub lp_unestimated_tasks {
  my ($self, $user, $lp_id) = @_;

  return unless $user && $user->lp_auth_header;

  $lp_id //= $user->lp_id;

  my $res = $self->http_get_for_user(
    $user,
    "$LP_BASE/upcoming_tasks?limit=200&member_id=" . $lp_id,
  );

  unless ($res->is_success) {
    warn "failed to get tasks from LiquidPlanner: " . $res->as_string;
    return;
  }

  my $groups = $JSON->decode( $res->decoded_content );
  return "no upcoming work... what??" unless @$groups;

  my @tasks;

  splice @$groups, 4;
  while (my $group = shift @$groups) {
    next unless $group->{items}->@*;

    for my $item ($group->{items}->@*) {
      # upcoming_tasks is meant to act like My Work, in which on-hold tasks are
      # not shown, but it includes on hold tasks.  bug filed
      next if $item->{is_on_hold};

      # Project, parent, and package are a complete mess, or at least mystery,
      # in the LiquidPlanner API.  Here, I'm trying to exclude tasks that are
      # in a project but not a package, meaning they're basically backlog work.
      next if $item->{project_id} && ! $item->{package_id};

      my ($assignment) = grep {; $_->{person_id} == $lp_id }
                         $item->{assignments}->@*;

      if ($self->_lp_task_is_unestimated($assignment)) {
        my $url = sprintf "https://app.liquidplanner.com/space/%s/projects/show/%s",
          $config->{liquidplanner}{workspace},
          $assignment->{treeitem_id};

        push @tasks, "$url\n";
      }
    }
  }

  return @tasks;
}

event irc_msg => sub {
  my ($self, $nickstr, $msg) = @_[ OBJECT, ARG0, ARG2 ];
  my ($nick) = split /!/, $nickstr;
  return if lc $nick eq 'slackbot';
  return if lc $nick eq 'bort';
  return if lc $nick eq 'trob';

  my $me = $self->get_nickname;
  $msg =~ s/\A \s* [@%]? \Q$me\E \s* (?: [,:] \s+)?//ix;

  my $arg = {
    how   => 'irc',
    who   => $nick,
    where => $nick,
    what  => $msg,
  };

  my $user  = $self->user_named($nick);
  my $timer = $user ? $user->timer : undef;

  if (  $timer && $timer->chill_until_active
    and $arg->{what} !~ /\bzzz\b/i
  ) {
    $timer->chill_until_active(0);
    $timer->clear_chilltill;
    $self->reply("You're back!  No longer chilling.", $arg)
      if $timer->is_business_hours;
  }

  my $result = $self->_dispatch($arg);

  return unless $result && $result == -1;

  $self->privmsg( $nick => "$nick: " . $self->_does_not_compute($user) );
};

event irc_public => sub {
  my ($self, $nickstr, $channel, $msg) = @_[ OBJECT, ARG0, ARG1, ARG2 ];
  my ($nick) = split /!/, $nickstr;
  return if lc $nick eq 'slackbot';
  return if lc $nick eq 'bort';
  return if lc $nick eq 'trob';

  my $arg = {
    how   => 'irc',
    who   => $nick,
    where => $channel,
    what  => $msg,
  };

  my $user  = $self->user_named($nick);
  my $timer = $user ? $user->timer : undef;

  if (  $timer && $timer->chill_until_active
    and $arg->{what} !~ /\bzzz\b/i
  ) {
    $timer->chill_until_active(0);
    $timer->clear_chilltill;
    $self->reply("You're back!  No longer chilling.", $arg);
  }
};

event irc_bot_addressed => sub {
  my ($self, $nickstr, $channel, $msg) = @_[ OBJECT, ARG0, ARG1, ARG2 ];
  my ($nick) = split /!/, $nickstr;
  return if lc $nick eq 'slackbot';
  return if lc $nick eq 'bort';
  return if lc $nick eq 'trob';

  my $result = $self->_dispatch({
    how   => 'irc',
    who   => $nick,
    where => $channel,
    what  => $msg,
  });

  return unless $result && $result == -1;

  my $user = $self->user_named($nick);
  $self->privmsg( $channel => "$nick: " . $self->_does_not_compute($user) );
};

has last_msgs => (
  is => 'ro',
  init_arg => undef,
  default  => sub {  {}  },
);

my %ALIAS = (
  say  => 'announce',
  '++' => 'plusplus',
  '>>' => 'angleangle',
  '+x' => 'addchecklist',
  new  => 'task',
  expando => 'expand',
);

my @BYE = (
  "See you later, alligator.",
  "After a while, crocodile.",
  "Time to scoot, little newt.",
  "See you soon, raccoon.",
  "Auf wiedertippen!",
  "Later.",
  "Peace.",
  "¡Adios!",
  "Au revoir.",
  "221 2.0.0 Bye",
  "+++ATH0",
  "Later, gator!",
  "Pip pip.",
  "Aloha.",
  "Farewell, %n.",
);

sub SAID_good {
  my ($self, $arg) = @_;

  return -1 unless length $arg->{what};
  my $what = lc $arg->{what};
  my $user = $self->user_named($arg->{who});

  $what =~ s/[\s1?!.]*\z//;

  my $reply = q{};
  my $expand;
  my $stop;
  my $end_of_day;

  if    ($what eq 'morning')   { $reply = "Good morning!"; $expand = 'morning' }
  elsif ($what eq 'afternoon') { $reply = "You, too!"; }
  elsif ($what eq 'day')       { $reply = "Long days and pleasant nights!"; }
  elsif ($what eq 'evening')   { $reply = "I'll be here when you get back!";
                                 $stop = 1; }
  elsif ($what eq 'night')     { $reply = "Sleep tight!";
                                 $stop = 1;
                                 $end_of_day = 1; }
  elsif ($what eq 'riddance')  { $reply = "I'll outlive you all.";
                                 $stop = 1;
                                 $end_of_day = 1; }
  elsif ($what eq 'bye')       { $reply = __pick_one(\@BYE);
                                 $stop = 1;
                                 $end_of_day = 1; }
  else                         { return; }

  if ($reply) {
    $reply =~ s/%n/$arg->{who}/g;
    $reply .= "  ";
  }

  if ($expand && $user && $user->tasks_for_expando($expand)) {
    $self->SAID_expand({
      %$arg,
      what => $expand,
      reply_buffer => \$reply,
    });
  }

  if ($stop && $user && $user->lp_auth_header) {
    my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");

    if ($res->is_success) {
      my @timers = grep {; $_->{running} }
                   @{ $JSON->decode( $res->decoded_content ) };

      if (@timers) {
        return $self->reply("You've got a running timer!  You should commit it.", $arg);
      }
    }
  }

  if ($end_of_day && (my $sy_timer = $user->timer)) {
    my $time = $self->_parse_time_hunk('until tomorrow', $user);
    $sy_timer->chilltill($time);
  }

  if ($reply) {
    $self->reply($reply, $arg);
  }

  return;
}

sub _dispatch {
  my ($self, $arg) = @_;

  my $msg = $arg->{what};

  if ($msg =~ s{\b(\S+) (?:http://|mailto:)\1 }{$1}g) {
    $self->info("removed Slack-added link");
  }

  my $last_ref = ref $arg->{how}
               ? \do { my $x }
               : \($self->last_msgs->{ $arg->{who} }->{ $arg->{how} });

  if ($msg eq 'commit that') {
    return "Sorry, I don't see a previous message from you." unless $$last_ref;
    local $arg->{what} = "commit: $$last_ref";
    return $self->_dispatch($arg);
  }

  if ($msg eq '++ that') {
    return "Sorry, I don't see a previous message from you." unless $$last_ref;
    local $arg->{what} = "++ $$last_ref";
    return $self->_dispatch($arg);
  }

  if ($msg =~ /\A\+\+ what (\S+) said\z/ && $arg->{how} eq 'irc') {
    my $who = $1;
    my $who_user = $self->resolve_name($who, $arg->{who});

    my $prev = $who_user
             ? $self->last_msgs->{ $who_user->username }->{ $arg->{how} }
             : undef;

    return "Sorry, I don't see a previous message from $who." unless $prev;
    local $arg->{what} = "++ $prev";
    return $self->_dispatch($arg);
  }

  $$last_ref = $msg;

  if (not ref $arg->{how}) {
    $self->last_msgs->{ $arg->{who} }->{ $arg->{how} } = $arg->{what};
  }

  # Genericize these: -- rjbs, 2014-06-19 -- rjbs, 2015-08-06
  $msg = "chill until I'm back" if lc $msg eq 'zzz';
  $msg = "good bye" if lc $msg eq 'bye'
                    or lc $msg eq 'adios';

  my ($cmd, $rest) = split ' ', $msg, 2;

  # First pass before stripping things down to alnum.
  $cmd = $ALIAS{$cmd} if $ALIAS{$cmd};

  $cmd =~ tr/[A-Za-z0-9]//dc;
  $cmd = lc $cmd;

  # Second pass for alnum aliases.
  $cmd = $ALIAS{$cmd} if $ALIAS{$cmd};

  my $method = "SAID_$cmd";
  $self->info("looking to call ->$method(" . ($rest // '') . ")");

  my %private = map {; $_ => 1 } qw( eject pose reload );

  return -1 unless $self->can("SAID_$cmd");

  if ($private{$cmd} && $arg->{who} ne $config->{master}) {
    return $self->reply("Only $config->{master} can do that.", $arg);
  }

  return $self->$method({ %$arg, what => $rest });
}

sub reply {
  my ($self, $reply, $arg) = @_;

  if ($arg->{reply_buffer}) {
    ${ $arg->{reply_buffer} } .= $reply;
  } elsif ($arg->{how} eq 'sms') {
    $self->sms($arg->{where}[0], $reply);
  } else {
    $self->privmsg($arg->{where}, "$arg->{who}: $reply");
  }

  return;
}

sub SAID_pose {
  my ($self, $arg) = @_;

  unless ($arg->{who} eq $config->{master}) {
    return -1;
  }

  my $what = $arg->{what};

  if ($what =~ s{\A\s*/me\s+}{}g) {
    # emote
  }

  $self->privmsg(
    $config->{irc}{channels}{general},
    $what,
  );

  return;
}

sub SAID_showtime {
  my ($self, $arg) = @_;

  my $user  = $self->user_named($arg->{who});
  my $timer = $user && $user->has_lp_id ? $user->timer : undef;

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $timer;

  if ($timer->has_chilltill and $timer->chilltill > time) {
    if ($timer->is_business_hours) {
      $self->reply("Okay, back to work!", $arg);
    } else {
      $self->reply("Back to normal business hours, then.", $arg);
    }
  } elsif ($timer->is_business_hours) {
    $self->reply("I thought it was already showtime!", $arg);
  } else {
    $timer->start_showtime;
    return $self->reply("Okay, business hours extended!", $arg);
  }

  $timer->clear_chilltill;
  return;
}

sub SAID_shows {
  my ($self, $arg) = @_;
  return $self->SAID_chill({ %$arg, what => 'until tomorrow' })
    if $arg->{what} =~ /\s*over\s*[+!.]*\s*/i;
  return -1;
}

sub date_parser_for {
  my ($self, $user) = @_;

  my $tz = $user ? $user->time_zone : 'America/New_York';

  DateTime::Format::Natural->new(
    prefer_future => 1,
    time_zone     => $tz,
  );
}

sub  _parse_time_hunk {
  my ($self, $hunk, $user) = @_;

  my ($prep, $rest) = split ' ', $hunk, 2;

  if ($prep eq 'for') {
    my $dur;
    $rest =~ s/^an?\s+/1 /;
    my $ok = eval { $dur = parse_duration($rest); 1 };
    return unless $ok;
    return time + $dur;
  }

  if ($prep eq 'until') {
    # XXX get the user in here -- rjbs, 2016-12-26
    my $dt = eval { $self->date_parser_for($user)->parse_datetime($rest) };
    return unless $dt;
    return $dt->epoch;
  }

  return;
}

sub SAID_chill {
  my ($self, $arg) = @_;

  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");

  if ($res->is_success) {
    my @timers = grep {; $_->{running} }
                 @{ $JSON->decode( $res->decoded_content ) };

    if (@timers) {
      return $self->reply("You've got a running timer!  Use 'commit' instead.", $arg);
    }
  }

  my $sy_timer = $user->timer;

  $arg->{what} =~ s/[.!?]+\z// if length $arg->{what};

  if (! length $arg->{what} or $arg->{what} =~ /^until\s+I'm\s+back\s*$/i) {
    $sy_timer->chill_until_active(1);
    POE::Kernel->yield('save_state');
    return $self->reply("Okay, I'll stop pestering you until you've active again.", $arg);
  }

  my $time = $self->_parse_time_hunk($arg->{what}, $user);
  return -1 unless defined $time;

  if ($time <= time) {
    $self->reply("That sounded like you want to chill until the past.", $arg);
    return;
  }

  my $when = DateTime->from_epoch(
    time_zone => $user->time_zone,
    epoch     => $time,
  )->format_cldr("yyyy-MM-dd HH:mm zzz");

  $sy_timer->chilltill($time);
  POE::Kernel->yield('save_state');
  $self->reply("Okay, no more nagging until $when", $arg);
}

sub SAID_mute {
  my ($self, $arg) = @_;
  return -1 unless $arg->{what} =~ s/\A\s*(alerts|all|\*)\s+//;

  my $user = $self->resolve_name($arg->{who});
  my $time = $self->_parse_time_hunk($arg->{what});
  return -1 unless defined $time;

  my $when = DateTime->from_epoch(
    time_zone => $user->time_zone,
    epoch     => $time,
  )->format_cldr("yyyy-MM-dd HH:mm zzz");

  $self->suppress_alerts_until($time);
  $self->reply(
    "Okay, won't relay alerts received between now and $when",
    $arg
  );
}

has reminders => (
  reader  => '_reminders',
  default => sub {  []  },
);

sub SAID_remind {
  my ($self, $arg) = @_;

  my ($who, $prep, $dur_str, $want_page, $rest) = $arg->{what} =~ qr/\A
    \s*
    (\S+)    # "me" or a nick
    \s+
    (in|at) # duration type
    \s+
    (.+?)    # duration
    (\s+with(?:out)?\s+page\s*)?
    :\s+     # the space is vital:  "at 15:15: eat pie"
    (.+)     # the reminder
    \z
  /x;

  unless (length $who) {
    warn("couldn't parse <<$arg->{what}>>");
    return -1;
  }

  unless ($prep) {
    warn("try 'remind <person> in/at <time>: <reminder>'");
    return -1;
  }

  $who = $self->resolve_name($who, $arg->{who});

  my $speaker = $self->resolve_name($arg->{who});

  if (defined $want_page) {
    # Requested specific page behaviour?
    if ($want_page =~ /out/) {
      $want_page = 0;
    } else {
      $want_page = 1;
    }
  } else {
    # User default (or page, if none specified)
    $want_page = $self->want_page_for_username($who->username);
  }

  my $time;
  if ($prep eq 'in') {
    my $dur;
    $dur_str =~ s/^an?\s+/1 /;
    my $ok = eval { $dur = parse_duration($dur_str); 1 };
    return -1 unless $ok;
    $time = time + $dur;
  } elsif ($prep eq 'at') {
    my $dt = eval { $self->date_parser_for($speaker)->parse_datetime($dur_str) };
    return -1 unless $dt;
    $time = $dt->epoch;
  } else {
    return -1;
  }

  if ($time <= time) {
    $self->reply("That sounded like you want a reminder sent in the past.", $arg);
    return;
  }

  my $target = $who->username eq $arg->{who} ? 'you' : $who->username;

  push @{ $self->_reminders}, {
    %$arg,
    when => $time,
    who  => $who->username,
    page => !! $want_page,
    what => $rest,
    requested_at => time,
  };

  POE::Kernel->yield('save_state');

  my $when = DateTime->from_epoch(
    time_zone => $who->time_zone,
    epoch     => $time,
  )->format_cldr("yyyy-MM-dd HH:mm zzz");

  $self->reply("Okay, I'll remind $target at $when.", $arg);
}

event check_reminders => sub {
  my ($self, $kernel) = @_[OBJECT, KERNEL];

  $self->info("checking for reminders");

  $self->delay(check_reminders => 30);

  my $reminders = $self->_reminders;

  my $changed;

  for my $i (reverse 0 .. $#$reminders) {
    my $reminder = $reminders->[$i];
    next unless $reminder->{when} <= time;

    $kernel->yield(send_reminder => $reminder);

    splice @$reminders, $i, 1;
    $changed = 1;
  }

  POE::Kernel->yield('save_state') if $changed;
  return;
};

event send_reminder => sub {
  my ($self, $reminder) = @_[OBJECT, ARG0];

  my $target = $self->resolve_name($reminder->{who});
  unless ($target) {
    # XXX real error reporting -- rjbs, 2016-12-26
    warn "UNKNOWN TARGET: $reminder->{who}";
    return;
  }

  my $when = DateTime->from_epoch(
    time_zone => $target->time_zone,
    epoch     => $reminder->{requested_at},
  )->format_cldr("yyyy-MM-dd HH:mm zzz");

  if ($reminder->{page}) {
    $self->sms($target->phone, "Reminder from $when: $reminder->{what}");
  }

  $self->reply(
    "Reminder from $when: $reminder->{what}",
    { where => $target->username},
  );
};

sub SAID_abort {
  my ($self, $arg) = @_;

  return $self->reply("I didn't understand your abort request. (try 'abort timer')", $arg)
    unless ($arg->{what} // 'timer') eq 'timer';

  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");

  return $self->reply("Something went wrong", $arg) unless $res->is_success;

  my ($timer) = grep {; $_->{running} }
                @{ $JSON->decode( $res->decoded_content ) };

  unless ($timer) {
    $self->reply("You don't have an active timer to abort.", $arg);
    return;
  }

  my $stop_res = $self->http_post_for_user($user, "$LP_BASE/tasks/$timer->{item_id}/timer/stop");
  my $clr_res  = $self->http_post_for_user($user, "$LP_BASE/tasks/$timer->{item_id}/timer/clear");

  if ($stop_res->is_success and $clr_res->is_success) {
    $user->timer->clear_last_nag;
    $self->reply("Okay, I stopped and cleared your active timer.", $arg);
  } else {
    $self->reply("Something went wrong aborting your timer.", $arg);
  }
}

sub SAID_reset {
  my ($self, $arg) = @_;

  return $self->reply("I didn't understand your reset request. (try 'reset timer')", $arg)
    unless ($arg->{what} // 'timer') eq 'timer';

  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");

  return $self->reply("Something went wrong", $arg) unless $res->is_success;

  my ($timer) = grep {; $_->{running} }
                @{ $JSON->decode( $res->decoded_content ) };

  unless ($timer) {
    $self->reply("You don't have an active timer to abort.", $arg);
    return;
  }

  my $clr_res  = $self->http_post_for_user($user, "$LP_BASE/tasks/$timer->{item_id}/timer/clear");

  if ($clr_res->is_success) {
    $user->timer->clear_last_nag;
    $self->reply("Okay, I cleared your active timer but left it running.", $arg);
  } else {
    $self->reply("Something went wrong resetting your timer.", $arg);
  }
}

sub SAID_done {
  my ($self, $arg) = @_;

  my $next;
  my $chill;
  if ($arg->{what}) {
    my @things = split /\s*,\s*/, $arg->{what};
    for (@things) {
      if ($_ eq 'next')  { $next  = 1; next }
      if ($_ eq 'chill') { $chill = 1; next }

      return -1;
    }

    return $self->reply("No, it's nonsense to chill /and/ start a new task!", $arg)
      if $chill && $next;
  }

  if ($next) {
    STRAW: {
      my $user = $self->user_named($arg->{who});
      last STRAW unless $user;

      my $lp_timer = $self->lp_timer_for_user($user);
      last STRAW unless $lp_timer && ref $lp_timer;

      my $tasks = $self->lp_tasks_for_user($user, 50);
      last STRAW unless $tasks and @$tasks;
      my ($i) = grep { $tasks->[$_]{id} == $lp_timer->{item_id} }
                (0 .. $#$tasks);

      last STRAW unless defined $i and $i < $#$tasks;

      $next = $tasks->[$i+1]{id};
    }
  }

  {
    my %arg = (%$arg, what => "done");
    my $rv = $self->SAID_commit(\%arg);

    return -1 if $rv && $rv == -1;
    return unless $rv;
  }

  $self->SAID_start({ %$arg, what => $next }) if $next;
  $self->SAID_chill({ %$arg, what => "until I'm back" }) if $chill;
  return;
}

sub SAID_commit {
  my ($self, $arg) = @_;

  my $comment = $arg->{what};

  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  my %meta;
  while ($comment =~ s/(?:\A|\s+)(DONE|STOP|CHILL)\z//) {
    $meta{$1}++;
  }

  $meta{DONE} = 1 if $comment =~ /\Adone\z/i;
  $meta{STOP} = 1 if $meta{DONE} or $meta{CHILL};

  my $lp_timer = $self->lp_timer_for_user($user);

  return $self->reply("You don't seem to have a running timer.", $arg)
    unless $lp_timer && ref $lp_timer; # XXX <-- stupid return type

  my $sy_timer = $user->timer;
  my $task_res = $self->http_get_for_user($user, "$LP_BASE/tasks/$lp_timer->{item_id}");

  my $activity_id;
  unless ($task_res->is_success) {
    return $self->reply("I couldn't log the work because I couldn't find the current task's activity id.", $arg);
  }

  my $task = $JSON->decode($task_res->decoded_content);
  $activity_id = $task->{activity_id};

  unless ($activity_id) {
    return $self->reply("I couldn't log the work because the task doesn't have a defined activity.", $arg);
  }

  my $content = $JSON->encode({
    is_done => $meta{DONE} ? \1 : \0,
    comment => $comment,
    restart => $meta{STOP} ? \0 : \1,
    activity_id => $activity_id,
  });

  if ($meta{STOP} and ! $sy_timer->chilling) {
    if ($meta{CHILL}) {
      $sy_timer->chill_until_active(1);
    } else {
      # Don't complain 30s after we stop work!  Give us a couple minutes to
      # move on to the next task. -- rjbs, 2015-04-21
      $sy_timer->chilltill(time + 300);
    }
  }

  my $commit_res = $self->http_post_for_user($user,
    "$LP_BASE/tasks/$lp_timer->{item_id}/timer/commit",
    Content => $content,
    Content_Type => 'application/json',
  );

  unless ($commit_res->is_success) {
    warn $commit_res->as_string;
    return $self->reply("I couldn't commit your work, sorry.", $arg);
  }

  $sy_timer->clear_last_nag;
  my $also
    = $meta{DONE}  ? " and marked the task done"
    : $meta{CHILL} ? " stopped the timer, and will chill until you're back"
    : $meta{STOP}  ? " and stopped the timer"
    :                "";

  my $time = concise( duration( $lp_timer->{running_time} * 3600 ) );
  $self->reply(
    sprintf("Okay, I've committed $time of work$also.%s",
      $meta{DONE} ? "  Task was: $task->{name}" : q{}),
    $arg
  );
  return 1;
}

sub SAID_start {
  my ($self, $arg) = @_;
  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  if ($arg->{what} =~ /\A[0-9]+\z/) {
    # TODO: make sure the task isn't closed! -- rjbs, 2016-01-25
    my $start_res = $self->http_post_for_user($user, "$LP_BASE/tasks/$arg->{what}/timer/start");
    my $timer = eval { $JSON->decode( $start_res->decoded_content ); };
    if ($start_res->is_success && $timer->{running}) {
      my $task_res = $self->http_get_for_user($user, "$LP_BASE/tasks/$timer->{item_id}");

      my $name = $task_res->is_success
               ? $JSON->decode($task_res->decoded_content)->{name}
               : '??';

      return $self->reply(
        "Started task: $name ($LINK_BASE$timer->{item_id})",
        $arg,
      );
    } else {
      return $self->reply("I couldn't start the timer for $arg->{what}.", $arg);
    }
  } elsif ($arg->{what} eq 'next') {
    my $lp_tasks = $self->lp_tasks_for_user($user, 1);

    unless ($lp_tasks && $lp_tasks->[0]) {
      return $self->reply("I can't get your tasks to start the next one.", $arg);
    }

    my $task = $lp_tasks->[0];
    my $start_res = $self->http_post_for_user($user, "$LP_BASE/tasks/$task->{id}/timer/start");
    my $timer = eval { $JSON->decode( $start_res->decoded_content ); };
    if ($start_res->is_success && $timer->{running}) {
      return $self->reply(
        "Started task: $task->{name} ($LINK_BASE$task->{id})",
        $arg,
      );
    } else {
      return $self->reply("I couldn't start your next task.", $arg);
    }
  }

  return -1;
}

sub SAID_stop {
  my ($self, $arg) = @_;

  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  if ($arg->{what} eq 'timer') {
    my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");

    return $self->reply("Something went wrong", $arg) unless $res->is_success;

    my ($timer) = grep {; $_->{running} }
                  @{ $JSON->decode( $res->decoded_content ) };

    my $stop_res = $self->http_post_for_user($user, "$LP_BASE/tasks/$timer->{item_id}/timer/stop");
    unless ($stop_res->is_success) {
      return $self->reply("I couldn't stop your active timer.", $arg);
    }

    $user->timer->clear_last_nag;
    $self->reply("Okay, I stopped your active timer.", $arg);
  } elsif ($arg->{what} =~ /\Ahitting yourself[.!]*\z/) {
    $self->reply("Quit it!  I'm telling mom!", $arg);
  } else {
    $self->reply("I didn't understand your stop request.", $arg);
  }
}

sub SAID_spent {
  my ($self, $arg) = @_;

  my $user = $self->user_named($arg->{who});
  $user = undef unless $user && $user->lp_auth_header;

  unless ($user) {
    return $self->reply(
      "You're not set up to do stuff in LiquidPlanner.",
      $arg,
    );
  }

  my ($dur_str, $name) = $arg->{what} =~ /\A(.+?)\s*(?::|\son\s)\s*(\S.+)\z/;
  unless ($dur_str && $name) {
    return -1;
  }

  my $duration;
  my $ok = eval { $duration = parse_duration($dur_str); 1 };
  unless ($ok) {
    return $self->reply("I didn't understand how long you spent!", $arg);
  }

  my $task = $self->_create_lp_task({
    name   => $name,
    # urgent => $urgent,
    user   => $user,
    owners => [ $user ],
    description => 'Created by Synergy in response to a "spent" command.',
  });

  unless ($task) {
    return $self->reply(
      "Sorry, something went wrong when I tried to make that task.",
      $arg,
    );
  }

  my $uri = sprintf
    'https://app.liquidplanner.com/space/%s/projects/show/%s',
    $config->{liquidplanner}{workspace},
    $task->{id};

  my $res = $self->http_post_for_user($user,
    "$LP_BASE/tasks/$task->{id}/track_time",
    Content_Type => 'application/json',
    Content => $JSON->encode({
      activity_id => $task->{activity_id},
      member_id => $user->lp_id,
      work      => $duration / 3600,
      is_done   => \1,
    }),
  );

  unless ($res->is_success) {
    warn $res->as_string;
    return $self->reply(
      "I was able to create the task, but not log your time.  Drat.  $uri",
      $arg,
    );
  }

  return $self->reply("I logged that time here: $uri", $arg);
}

sub SAID_damage {
  my ($self, $arg) = @_;

  $arg->{what} =~ s/\A\s*//;
  $arg->{what} =~ s/\Areport\s*//;
  $arg->{what} =~ s/\Afor (\S+)\z//;
  my $for_str = $1 // $arg->{who};

  return -1 if $arg->{what};

  my $who = $self->user_named($arg->{who});
  my $for = $self->user_named($for_str);

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $who && $who->lp_auth_header;

  unless ($for and $for->lp_id) {
    return $self->reply(
      "I don't know who the user $for_str is in LiquidPlanner.",
      $arg,
    );
  }

  my $report = $self->lp_damage_report($who, $for->lp_id);
  return $self->reply($report, $arg);
}

sub SAID_unestimated {
  my ($self, $arg) = @_;

  $arg->{what} //= '';
  $arg->{what} =~ s/\A\s*//;
  $arg->{what} =~ s/\Areport\s*//;
  $arg->{what} =~ s/\Afor (\S+)\z//;
  my $for_str = $1 // $arg->{who};

  return -1 if $arg->{what};

  my $who = $self->user_named($arg->{who});
  my $for = $self->user_named($for_str);

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $who && $who->lp_auth_header;

  unless ($for and $for->lp_id) {
    return $self->reply(
      "I don't know who the user $for_str is in LiquidPlanner.",
      $arg,
    );
  }

  my @tasks = $self->lp_unestimated_tasks($who, $for->lp_id);

  if ($arg->{how} eq 'irc' && $arg->{where} ne $arg->{who}) {
    $self->reply("Responses to <unestimated> are sent privately.", $arg);
    $arg->{where} = $arg->{who};
  }

  $self->reply($_, $arg) for @tasks;

  return;
}

sub SAID_tasks {
  my ($self, $arg) = @_;
  $self->_task_list($arg, { inbox => 0 });
}

sub SAID_inbox {
  my ($self, $arg) = @_;
  $self->_task_list($arg, { inbox => 1 });
}

sub _task_list {
  my ($self, $arg, $meta) = @_;

  my $command = $meta->{inbox} ? 'inbox' : 'tasks';

  my $user  = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  if ($arg->{how} eq 'irc' && $arg->{where} ne $arg->{who}) {
    $self->reply("Responses to <$command> are sent privately.", $arg);
    $arg->{where} = $arg->{who};
  }

  my @tasks;
  my $what = $arg->{what} // 1;

  if ($what =~ /\A[0-9]+\z/ && $what > 0) {
    my $per_page = 5;
    my $page = $what;

    unless ($page <= 10) {
      return $self->reply(
        "If it's not in your first ten pages, better go to the web.",
        $arg,
      );
    }

    my $count = $per_page * $page;
    my $start = $per_page * ($page - 1);

    my $lp_tasks = $self->lp_tasks_for_user($user, $count, $meta);
    @tasks = splice @$lp_tasks, $start, $per_page;
  } elsif ($what =~ m{\A/(.+)/\z}) {
    $what = $1;
    my $lp_tasks = $self->lp_tasks_for_user($user, 50, $meta);
    @tasks = grep {; $_->{name} =~ /$what/ } @$lp_tasks;
    $#tasks = 4 if @tasks > 5;
  } else {
    return -1;
  }

  for my $task (@tasks) {
    $self->reply("$task->{name} ($LINK_BASE$task->{id})", $arg);
  }

  return;
}

sub master_lp_user {
  $_[0]->user_named( $config->{master} );
}

sub SAID_status {
  my ($self, $arg) = @_;
  my $uptime = duration(time - $^T);
  return $self->reply("Online for $uptime.", $arg);
}

sub SAID_timer {
  my ($self, $arg) = @_;

  my $user = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  my $res = $self->http_get_for_user($user, "$LP_BASE/my_timers");

  unless ($res->is_success) {
    $self->reply("I couldn't get your timer.", $arg);
    warn $res->as_string;
    return;
  }

  my @timers = grep {; $_->{running} }
               @{ $JSON->decode( $res->decoded_content ) };

  my $sy_timer = $user->timer;

  unless (@timers) {
    my $nag = $sy_timer->last_relevant_nag;
    my $msg;
    if (! $nag) {
      $msg = "You don't have a running timer.";
    } elsif ($nag->{level} == 0) {
      $msg = "Like I said, you don't have a running timer.";
    } else {
      $msg = "Like I keep telling you, you don't have a running timer!";
    }

    return $self->reply($msg, $arg);
  }

  if (@timers > 1) {
    $self->reply(
      "Woah.  LiquidPlanner says you have more than one active timer!",
      $arg,
    );
  }

  my $timer = $timers[0];
  my $time = concise( duration( $timer->{running_time} * 3600 ) );
  my $task_res = $self->http_get_for_user($user, "$LP_BASE/tasks/$timer->{item_id}");

  my $name = $task_res->is_success
           ? $JSON->decode($task_res->decoded_content)->{name}
           : '??';

  my $url = sprintf "https://app.liquidplanner.com/space/%s/projects/show/%s",
    $config->{liquidplanner}{workspace},
    $timer->{item_id};

  $self->reply(
    "Your timer has been running for $time, work on: $name <$url>",
    $arg,
  );
}

sub SAID_oncall {
  my ($self, $arg) = @_;

  my ($flag, @users) = split / /, ($arg->{what} // '');
  s/,$//g for @users;

  my $contact_group = $self->get_oncall_list;

  my @to_reply;

  if ($flag) {
    my @errors = $self->_do_oncall_update($arg->{who}, $contact_group, $flag, \@users);
    $self->reply($_, $arg) for @errors;
    return if @errors;
    push @to_reply, "Okay, oncall group updated!";
  }

  my $oncall = $self->_format_oncall_group($contact_group);
  $self->reply(join(q{  }, @to_reply, "Now on call: $oncall"), $arg);
}

sub _format_oncall_group {
  my ($self, $group) = @_;

  # Do we want to show externals here, too, just in case? -- rjbs, 2014-06-09
  my @current = @{ $group->{users} };

  my %user;
  foreach my $contact (@current) {
    my ($id) = $contact->{user} =~ m{/user/([0-9]+)\z};
    my $user = $self->user_for_circonus_id($id);
    my $username = $user ? $user->username : "#$id";
    $user{$username}{$contact->{method}} = 1;
  }

  my $str = join q{; },
            map {; sprintf '%s (%s)', $_, (join q{, }, sort keys %{ $user{$_} }) }
            sort keys %user;

  return $str;
}

sub _do_oncall_update {
  my ($self, $who_said, $contact_group, $flag, $users) = @_;

  my @current;

  unless ($flag eq "set") {
    foreach my $now (@{ $contact_group->{users} }){
      my ($foo, $user, $id) = split('/', $now->{user});
      push @current, $id;
    }
  }

  foreach my $who (@$users) {
    my $user = $self->resolve_name($who, $who_said);
    if ($user && $user->has_circonus_id) {
      my $method = "$flag\_oncall";

      return "I don't understand your command '$flag'"
        unless $self->can($method);

      $self->$method(\@current, $user->circonus_id);
    } else {
      return "$who is unknown. Try using another name, or use their contact ID number."
    }
  }

  if (my $error = $self->update_oncall_list($contact_group->{external}, @current)) {
    return $error;
  }

  # We (presumably) updated the on-call list, so update the one we will print.
  %$contact_group = %{ $self->get_oncall_list };

  return;
}

sub get_oncall_list {
  my ($self) = @_;
  my $res = $self->circ_get("$CIRC_BASE/contact_group/$config->{circonus}{oncall_group}");
  my $json = $res->decoded_content;
  my $contacts = $JSON->decode($json);
  return $contacts->{contacts};
}

sub update_oncall_list {
  my ($self, $external, @current) = @_;

  my @to_send;
  foreach my $person (@current) {
    my $res = $self->circ_get("$CIRC_BASE/user/$person");
    my $json = $res->decoded_content;
    my $contact_info = $JSON->decode($json);
    my @this = (
      ($contact_info->{contact_info}{sms}
        ?  {
            '_contact_info' => $contact_info->{contact_info}->{sms},
            'user' => $contact_info->{_cid},
            'method' => 'sms'
          }
        : ()
      ),
      ($contact_info->{email}
        ?  {
            '_contact_info' => $contact_info->{email},
            'user' => $contact_info->{_cid},
            'method' => 'email'
          }
        : ()
      )
    );
    return "There's no useful contact info in Circonus for user $person."
      unless @this;
    push @to_send, @this;
  }

  my $set_struct = $JSON->encode({
    contacts => {
      users => \@to_send,
      external => $external,
    },
  });

  my $result = $self->circ_put(
    "$CIRC_BASE/contact_group/$config->{circonus}{oncall_group}",
    Content => $set_struct,
    Content_Type => 'application/json',
  );

  return;
}

sub add_oncall {
  my ($self, $current, $id) = @_;
  push @$current, $id unless grep { $_ == $id } @$current;
}

sub remove_oncall {
  my ($self, $current, $id) = @_;

  @$current = grep {; $_ != $id } @$current;
}

sub set_oncall {
  my ($self, $current, $id) = @_;

  push @$current, $id;
}

sub SAID_plusplus {
  my ($self, $arg) = @_;

  if (! length $arg->{what}) {
    return $self->reply("Thanks, but I'm only as awesome as my creators.", $arg);
  }

  return $self->SAID_task({
    %$arg,
    what => "for $arg->{who}: $arg->{what}",
  });
}

sub SAID_angleangle {
  my ($self, $arg) = @_;
  my $what = $arg->{what};

  if (! length $what) {
    return -1;
  }

  $what =~ s/\A\s*(\S+?):?\s+//;
  my $who = $1;

  return $self->SAID_task({
    %$arg,
    what => "for $who: $what",
  });
}

sub SAID_addchecklist {
  my ($self, $arg) = @_;

  my $user = $self->user_named($arg->{who});

  return -1 unless $arg->{what} =~ /\S/;

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  return $self->reply("You can't add checklist items unless you've got a running LiquidPlanner timer.", $arg)
    unless my $lp_timer = $self->lp_timer_for_user($user);

  my $desc = $arg->{what};

  if ($desc =~ /^\s*for\s+\S+?:/) {
    # XXX adding this should be easy -- rjbs, 2016-01-08
    return $self->reply("Sorry, I can't make checklist items for other users yet.", $arg);
  }

  my $res = $self->http_post_for_user($user,
    "$LP_BASE/tasks/$lp_timer->{item_id}/checklist_items",
    Content_Type => 'application/json',
    Content => $JSON->encode({ checklist_item => { name => $desc } }),
  );

  my $reply = $res->is_success
            ? "I've added the checklist item for you."
            : "Sorry, I couldn't add that item... for... some reason.";

  return $self->reply($reply, $arg);
}

sub SAID_alerts {
  my ($self, $arg) = @_;

  my $res = $self->circ_get("$CIRC_BASE/alert");
  my $json = $res->decoded_content;
  my $alerts = $JSON->decode($json);

  return $self->reply("Everything's okay!", $arg) unless @$alerts;

  for my $event (@$alerts) {
    my $response = sprintf '%s %s %s',
      $event->{_cid}, $event->{_check_name}, $event->{_alert_url};
    $self->reply($response, $arg);
  }
}

sub SAID_ack {
  my ($self, $arg) = @_;

  return $self->reply("It's: ack <alert-id or *> for <duration>")
    unless my ($alert_id, $dur_str) = $arg->{what} =~ /\A(\S+)(?:\s+for\s+(.+?))?\s*\z/;

  $dur_str = '15m' unless $dur_str;

  my $do_multi;
  if ($alert_id =~ /\A\*|all|that|those\z/) {
    $do_multi = 1;
  } elsif ($alert_id !~ /\A[0-9]+\z/) {
    return $self->reply(
      qq{"$alert_id" doesn't look like a cromulent alert id.  } .
      qq{They're just numbers!},
      $arg
    );
  }

  my $dur;
  my $ok = eval { $dur = parse_duration($dur_str); 1 };

  return $self->reply("I didn't understand how long you wanted to ack it!", $arg)
    unless $ok;

  my $min = int($dur / 60);

  return $self->reply("You can't ack something for less than a minute!", $arg)
    unless $min;

  my $long = concise(duration($dur - $dur % 60));

  if ($do_multi) {
    my $stash = $self->recent_alerts;
    unless (keys %$stash) {
      return $self->reply("There are no recent alerts to ack!", $arg);
    }

    my @acked;
    my @failed;

    for my $alert_id (keys %$stash) {
      my $alert = $stash->{$alert_id};
      my $desc = sprintf "(%s on %s)", $alert->{metric_name}, $alert->{host};
      if ($self->_ack_alert_for($alert_id, $min)) {
        push @acked, $desc;
      } else {
        push @failed, $desc;
      }
    }

    if (@acked) {
      $self->reply("Acked for $long: " . join(q{, }, @acked), $arg);
    }
    if (@failed) {
      $self->reply("Failed to ack: " . join(q{, }, @failed), $arg);
    }

    return;
  } else {
    my $acked = $self->_ack_alert_for($alert_id, $min);

    if ($acked) {
      return $self->reply("Alert $alert_id acked for $long.", $arg);
    } else {
      return $self->reply(
        "Alert couldn't be acked.  Maybe check 'alerts'?",
        $arg,
      );
    }
  }
}

sub _ack_alert_for {
  my ($self, $alert_id, $min) = @_;

  my $check = $self->circ_get("$CIRC_BASE/alert/$alert_id");

  unless ($check->is_success) {
    $self->info("Found no alert for id $alert_id");
    return;
  }

  my $content = $JSON->encode({
    acknowledged_until => $min . 'm',
    alert              => "/alert/$alert_id",
  });

  my $res = $self->circ_post(
    "$CIRC_BASE/acknowledgement",
    Content => $content,
    Content_Type => 'application/json',
  );

  unless ($res->is_success) {
    $self->info("non-successful attempt to ack /alert/$alert_id for ${min}m");
    warn $res->decoded_content;
    return;
  }

  return $res->is_success;
}

sub SAID_maint {
  my ($self, $arg) = @_;

  return -1
    unless my ($target, $dur_str) = $arg->{what} =~ /\A(\S+)(?:\s+for\s+(.+?))?\s*\z/;

  $target =~ s{^http://}{}; # Slack, sometimes you suck. -- rjbs, 2015-04-06

  $dur_str = '15m' unless $dur_str;

  my $is_host;

  if ($target eq '*') {
    # We'll do multi-ack.
    return $self->reply("Multi-maint not yet implemented", $arg);
  } if ($target =~ /\A[0-9]+\z/) {
    $is_host = 0;
  } elsif ($target =~ /\A(?:[-0-9a-z]+\.)*[-0-9a-z]+\z/) {
    $is_host = 1;
  } else {
    return $self->reply("I don't know what kind of maint $target is.", $arg);
  }

  my $dur;
  my $ok = eval { $dur = parse_duration($dur_str); 1 };

  return $self->reply("I didn't understand how long you wanted to ack it!", $arg)
    unless $ok;

  my $min = int($dur / 60);

  return $self->reply("You can't maint something for less than a minute!", $arg)
    unless $min;

  my $long = concise(duration($dur - $dur % 60));

  if ($is_host) {
    if ($self->_maint_host_for($target, $min)) {
      return $self->reply("Maintenance for host $target begun!", $arg)
    }

    return $self->reply("Sorry, I couldn't start a maintenance window for host $target!", $arg)
  }

  if ($self->_maint_alert_for($target, $min)) {
    return $self->reply("Maintenance for alert $target begun!", $arg)
  }

  return $self->reply("Sorry, I couldn't start a maintenance window for alert $target!", $arg)
}

sub _maint_alert_for {
  my ($self, $alert_id, $min) = @_;

  my $check = $self->circ_get("$CIRC_BASE/alert/$alert_id");

  return unless $check->is_success;

  my $alert = $JSON->decode( $check->decoded_content );
  my $check_path = $alert->{_check};

  my $content = $JSON->encode({
    item       => $check_path,
    severities => [ 1..5 ],
    start      => time,
    stop       => time  +  $min * 60,
    notes      => "requested via Synergy",
    type       => 'check',
  });

  my $res = $self->circ_post(
    "$CIRC_BASE/maintenance",
    Content => $content,
    Content_Type => 'application/json',
  );

  warn "MAINT FAIL: " . $res->as_string unless $res->is_success;

  return $res->is_success;
}

sub _maint_host_for {
  my ($self, $host, $min) = @_;

  my $content = $JSON->encode({
    item       => "$host",
    severities => [ 1..5 ],
    start      => time,
    stop       => time  +  $min * 60,
    notes      => "requested via Synergy",
    type       => 'host',
  });

  my $res = $self->circ_post(
    "$CIRC_BASE/maintenance",
    Content => $content,
    Content_Type => 'application/json',
  );

  warn "MAINT FAIL: " . $res->as_string unless $res->is_success;

  return $res->is_success;
}


sub _create_lp_task {
  my ($self, $arg) = @_;

  my $payload = { task => {
    name     => $arg->{name},
    ($arg->{urgent} ? (parent_id => $config->{liquidplanner}{urgent}) : ()),
    assignments => [ map {; { person_id => $_->lp_id } } @{ $arg->{owners} } ],
    description => $arg->{description},
  } };

  my $as_user = $arg->{user} // $self->master_lp_user;

  my $res = $self->http_post_for_user(
    $as_user,
    "$LP_BASE/tasks",
    Content_Type => 'application/json',
    Content => $JSON->encode($payload),
  );

  unless ($res->is_success) {
    warn ">>" . $res->decoded_content . "<<";
    warn $res->as_string;
    return;
  }

  my $task = $JSON->decode($res->decoded_content);

  return $task;
}

sub SAID_task {
  my ($self, $arg) = @_;

  # because of "new task for...";
  my $what = $arg->{what} =~ s/\Atask\s+//r;

  my ($target, $name) = $what =~ /\s*for\s+@?(.+?)\s*:\s+(.+)\z/;

  return -1 unless $target and $name;

  my @target_names = split /(?:\s*,\s*|\s+and\s+)/, $target;
  my (@owners, @no_lp, @unknown);
  my %seen;
  for my $name (@target_names) {
    my $target = $self->resolve_name($name, $arg->{who});

    next if $target && $seen{ $target->username }++;

    my $owner_id = $target ? $target->lp_id : undef;

    # Sadly, the following line is not valid:
    # push(($owner_id ? @owner_ids : @unknown), $owner_id);
    if ($owner_id) {
      push @owners, $target;
    } elsif ($target) {
      push @no_lp, $target->username;
    } else {
      push @unknown, $name;
    }
  }

  if (@unknown or @no_lp) {
    my @fail;

    if (@unknown) {
      my $str = @unknown == 1 ? "$unknown[0] is"
              : @unknown == 2 ? "$unknown[0] or $unknown[1] are"
              : join(q{, }, @unknown[0 .. $#unknown-1], "or $unknown[-1] are");
      push @fail, "I don't know who $str.";
    }

    if (@no_lp) {
      my $str = @no_lp == 1 ? $no_lp[0]
              : @no_lp == 2 ? "$no_lp[0] or $no_lp[1]"
              : join(q{, }, @no_lp[0 .. $#no_lp-1], "or $no_lp[-1]");
      push @fail, "There's no LiquidPlanner user for $str.";
    }

    return $self->reply(join(q{  }, @fail), $arg);
  }

  my ($urgent, $start);
  if ($name =~ s/\s*\(([!>]+)\)\s*\z//) {
    my ($code) = $1;
    $urgent = $code =~ /!/;
    $start  = $code =~ />/;
  } elsif ($name =~ s/\s*((?::timer_clock:|:hourglass(?:_flowing_sand)?:|:exclamation:)+)\s*\z//) {
    my ($code) = $1;
    $urgent = $code =~ /exclamation/;
    $start  = $code =~ /timer_clock|hourglass/;
  }

  my $where = ref $arg->{where} ? $arg->{where}[0] : $arg->{where};
  my $via   = $arg->{how} eq 'sms'  ? 'an SMS'
            : $where =~ /^#/        ? "a message on $where"
            :                         "a private message";

  my $user = $self->user_named($arg->{who});
  $user = undef unless $user && $user->lp_auth_header;

  my $description = sprintf 'created by %s in response to %s from %s%s',
    $self->get_nickname,
    $via,
    $arg->{who};

  my $task = $self->_create_lp_task({
    name   => $name,
    urgent => $urgent,
    user   => $user,
    owners => \@owners,
    description => $description,
  });

  unless ($task) {
    return $self->reply(
      "Sorry, something went wrong when I tried to make that task.",
      $arg,
    );
  }

  my $rcpt = join q{ and }, map {; $_->username } @owners;

  my $reply = sprintf
    "Task for $rcpt created: https://app.liquidplanner.com/space/%s/projects/show/%s",
    $config->{liquidplanner}{workspace},
    $task->{id};

  if ($start) {
    if ($user) {
      my $res = $self->http_post_for_user($user, "$LP_BASE/tasks/$task->{id}/timer/start");

      if ($res->is_success) {
        $reply =~ s/created:/created, timer running:/;
      } else {
        $reply =~ s/created:/created, timer couldn't be started:/;
      }
    } else {
      $reply =~ s/created:/created, timer couldn't be started:/;
    }
  }

  $self->reply($reply, $arg);
}

sub SAID_expand {
  my ($self, $arg) = @_;

  my $user = $self->user_named($arg->{who});

  return $self->reply("You don't seem to be a LiquidPlanner-enabled user.", $arg)
    unless $user && $user->lp_auth_header;

  my @tasks = $user->tasks_for_expando($arg->{what});

  return $self->reply("You don't have an expando for: $arg->{what}", $arg)
    unless @tasks;

  my $parent = $config->{liquidplanner}{recurring};
  my $where  = ref $arg->{where} ? $arg->{where}[0] : $arg->{where};

  my (@ok, @fail);

  for my $task (@tasks) {
    my $payload = { task => {
      name     => $task,
      parent_id   => $parent,
      assignments => [ { person_id => $user->lp_id } ],
      description => "created by " . $self->get_nickname . " on $where "
                  .  "on behalf of $arg->{who}",
    } };

    warn $JSON->encode($payload);

    my $res = $self->http_post_for_user($user,
      "$LP_BASE/tasks",
      Content_Type => 'application/json',
      Content => $JSON->encode($payload),
    );

    if ($res->is_success) {
      push @ok, $task;
    } else {
      warn $res->decoded_content;
      push @fail, $task;
    }
  }

  my $reply;
  if (@ok) {
    $reply = "I created your $arg->{what} tasks: " . join(q{; }, @ok);
    $reply .= "  Some tasks failed to create: " . join(q{; }, @fail) if @fail;
  } elsif (@fail) {
    $reply = "Your $arg->{what} tasks couldn't be created.  Sorry!";
  } else {
    $reply = "Something impossible happened.  How exciting!";
  }

  $self->reply($reply, $arg);
}

sub SAID_page {
  my ($self, $arg) = @_;
  $arg->{what} =~ s/\A\s+//;
  $arg->{what} =~ s/\s+\z//;

  if ($arg->{what} =~ /\A(\w+)[.?!]*\z/) {
    my $who = $1;
    my $target = $self->resolve_name($who, $arg->{who});

    unless ($target->has_phone) {
      return $self->reply("I don't have a number for $who.", $arg);
    }

    my $where = ref $arg->{where} ? "@{$arg->{where}}" : $arg->{where};
    $self->sms($target->phone, "$arg->{who} just paged you on $where");
    $self->reply("Okay, I sent a page.", $arg);
    return;
  }

  my ($who, $rest) = split /\s*:\s*/, $arg->{what}, 2;
  my $target = $self->resolve_name($who, $arg->{who});

  unless ($arg->{what} and $arg->{what} =~ /\S/) {
    return $self->reply(
      "It goes:  <<page whoever>> or <<page whoever: message>>",
      $arg,
    );
  }

  unless ($target and $target->phone) {
    return $self->reply("I don't have a number for $who.", $arg);
  }

  my $where = ref $arg->{where} ? "@{$arg->{where}}" : $arg->{where};
  $self->sms(
    $target->phone,
    "$arg->{who} just paged you on $where: $rest",
  );
  $self->reply("Okay, I sent a page.", $arg);
  return;
}

sub SAID_whats {
  my ($self, $arg) = @_;
  return $self->SAID_what({ %$arg, what => "is $arg->{what}" });
}

sub _fmt_ph {
  my ($self, $ph) = @_;

  my ($c, $ac, $ex, $rest) = $ph =~ m{
    \A
    ([0-9])? ([0-9]{3}) ([0-9]{3}) ([0-9]{4})
    \z
  }x;

  # not American-looking
  return $ph unless $ac;

  $c //= 1;

  return "+$c $ac $ex-$rest";
}

sub SAID_who {
  my ($self, $arg) = @_;
  my $what = $arg->{what};
  $what =~ s/\s*\?*\z//;

  if ($what =~ /\A\s*(is|are)\s+(you|synergy)\s*\z/) {
    return $self->reply(
      qq!I am Synergy, a holographic computer designed to be the ultimate audio-visual entertainment synthesizer.  I also help out with the timekeeping.!,
      $arg,
    );
  }

  return -1 unless $what =~ s/\Ais\s+//;

  my $who = $self->resolve_name($what, $arg->{who});
  return $self->reply(qq!I don't know who "$what" is.!, $arg) if ! $who;

  my $whois = sprintf "%s (%s)", $who->username, $who->realname;

  if ($what eq $who->username) {
    return $self->reply(qq{"$what" is $whois.}, $arg);
  }

  return $self->reply(qq["$what" is an alias for $whois.], $arg);
}

sub SAID_what {
  my ($self, $arg) = @_;
  my $what = $arg->{what};
  $what =~ s/\s*\?*\z//;
  return -1 unless $what =~ s/\Ais //;

  if ($what =~ /\Ayour (?:phone )?number\z/) {
    my $num = $self->_fmt_ph($config->{twilio}{from});
    return $self->reply("You can text me at $num.", $arg);
  }

  if ($what =~ /\A(\S+?)(?:'s)? (?:phone )?number\z/) {
    my $who  = $1;
    my $user = $self->resolve_name($who, $arg->{who});

    my $name = $user ? $user->username : $who;

    return $self->reply("I don't have a number on file for $name.", $arg)
      unless $user && $user->has_phone;

    my $num = $self->_fmt_ph($user->phone);
    return $self->reply(
      sprintf("You can reach %s at %s.", $user->username, $user->phone),
      $arg,
    );
  }

  return -1;
}

sub SAID_reload {
  my ($self, $arg) = @_;

  return -1 unless $arg->{what} eq 'config';

  $config = YAML::XS::LoadFile($ENV{SYNERGY_CONFIG});

  # All of these are potentially invalidated by a config reload. -- rjbs,
  # 2014-06-10
  $self->_clear_users;

  return $self->reply("Configuration reloaded.", $arg);
}

sub SAID_compose {
  my ($self, $arg) = @_;

  return -1 unless lc $arg->{what} =~ /\Aa haiku\s*(?:for (\S+)\s*)?\z/;
  my $for = $1;

  my $haiku;
  my $ok = eval { require Haiku; $haiku = join q{ / }, Haiku::haiku(); 1 };

  return $self->reply("The muse is not with me.", $arg) unless $ok;

  if (my $for = $self->resolve_name($for, $arg->{who})) {
    unless ($for->has_phone) {
      return $self->reply(
        sprintf("I don't know two to reach %s.", $for->username),
        $arg,
      );
    }

    $self->sms($for->phone, "A haiku from $arg->{who}: $haiku");
    return $self->reply("Poem dispatched.", $arg);
  }

  return $self->reply($haiku, $arg);
}

my %HELP = (
  "++"     => "++ == task for me",
  ">>"     => ">> <person> == task for <person>",
  abort    => "abort timer -- stop and clear the timer (LP users only)",
  ack      => "ack ALERTID [for DURATION] -- acknowledge an alert",
  # addchecklist => "add checklist items to your currently running task",
  alerts   => "alerts -- list active Circonus alerts",
  announce => "announce MESSAGE -- say something on IRC, for use via SMS",
  chill    => "chill [until TIME | for DURATION] -- stop nagging for a while (LP users only)",
  clox     => "what time is it in everybody's TZ now?",
  commit   => "commit work on your current timer; pair with STOP or DONE",
  damage   => "what is coming up, and what needs to be estimated?",
  good     => "set up recurring tasks with good [morning|afternoon|etc]",
  maint    => "maint <ALERTID> [for DURATION] -- set a maintenance window for an alert",
  oncall   => "oncall -- list on call users; also, (oncall add SOMEBODY, oncall remove SOMEBODY, oncall set SOMEBODY...)",
  page     => "page SOMEBODY: message -- send an SMS to a user",
  remind   => "remind SOMEBODY [at TIME | in DURATION]: WHAT -- set up a reminder",
  reset    => "reset timer -- clear the timer, leave it running (LP user onlys)",
  showtime => "showtime -- stop chilling, start nagging",
  "show's over" => "show's over -- chill for the rest of the day",
  start    => "start [TASKID] -- start next upcoming task, or task ID TASKID ",
  tasks    => "tasks [ N ] -- see your upcoming 5 tasks, or 'page' N of your tasks ",
  spent    => "spent DURATION on TASK: make a task, already complete, with time logged on it",
  timer    => "timer -- show timer status (LP users only)",
  stop     => "stop timer -- stop the current timer (LP users only)",
  task     => "task for SOMEBODY: TASK -- make a new task in Liquid Planner",
  what     => "what's SOMEBODY number -- get a user's phone number",
  who      => "who is SOMEBODY -- get a user or alias's identity",
);

sub SAID_help {
  my ($self, $arg) = @_;

  unless (length $arg->{what}) {
    return $self->reply("known commands: " . (join q{, }, sort keys %HELP), $arg);
  }

  my $help = $HELP{$arg->{what}};

  return $self->reply("unknown command", $arg) unless $help;
  return $self->reply($help, $arg);
}

sub SAID_clox {
  my ($self, $arg) = @_;
  my $now = DateTime->now;

  my $str = q{};
  for my $tz_name (@{ $config->{time_zones}}) {
    my $tz = DateTime::TimeZone->new(name => $tz_name);
    my $tz_now = $now->clone;
    $tz_now->set_time_zone($tz);

    $str .= "; " if length $str;
    $str .= $tz_now->day_name . ", " . $tz_now->format_cldr("H:mm vvv");
  }

  my $sit = $now->clone;
  $sit->set_time_zone('+0100');

  $str .= "; " . $sit->ymd('-') . '@'
      . int(($sit->second + $sit->minute * 60 + $sit->hour * 3600) / 86.4);

  return $self->reply($str, $arg);
}

sub state {
  my ($self) = @_;
  my %state = (reminders => $self->_reminders);

  my %timers;
  for my $username ($self->usernames) {
    next unless my $user  = $self->user_named($username);
    next unless my $timer = $user->timer;
    $timers{ $username } = $timer->as_hash;
  }

  $state{timers} = \%timers;
  return \%state;
}

event save_state => sub {
  my ($self) = @_[OBJECT,];

  return unless $config->{state_file};

  my $state = $self->state;
  path($config->{state_file})->spew_utf8( $JSON->encode($state) );
  return;
};

sub load_state {
  my ($self) = @_;

  return unless $config->{state_file} and -r $config->{state_file};
  my $state = $JSON->decode( path($config->{state_file})->slurp_utf8 );

  @{ $self->_reminders } = @{ $state->{reminders} };

  my $timers = $state->{timers};
  for my $username (keys %$timers) {
    my $timer_state = $state->{timers}{$username};
    next unless $timer_state->{chill};

    next unless my $user  = $self->user_named($username);
    next unless my $timer = $user->timer;

    if ($timer_state->{chill}{type} eq 'until_active') {
      $timer->clear_chilltill;
      $timer->chill_until_active(1);
    } elsif ($timer_state->{chill}{type} eq 'until_time') {
      $timer->chill_until_active(0);
      $timer->chilltill($timer_state->{chill}{until});
    } else {
      warn "@#!@#!@ weird chill type";
    }
  }
}

sub BUILD {
  my ($self) = @_;

  $self->delay(nag => 60);
  $self->delay(check_reminders => 60);
  $self->load_state;
}

__PACKAGE__->run;
