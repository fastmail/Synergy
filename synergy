#!perl
use 5.16.0;
package Synergy;
use Moses;
use namespace::autoclean;

use DateTime::Format::Natural;
use HTTP::Body;
use JSON 2 ();
use JSON::PP qw(encode_json decode_json);
use LWP::UserAgent::POE;
use MIME::Base64;
use POE::Component::Server::SimpleHTTP;
use Time::Duration::Parse;
use Time::Duration;
use YAML::XS;
use Data::Dumper;

my $JSON = JSON->new;

die "no config file" unless -e $ENV{SYNERGY_CONFIG};
my $config = YAML::XS::LoadFile($ENV{SYNERGY_CONFIG});

server   $config->{server};
nickname $config->{nickname};
username $config->{username};
channels @{ $config->{channels} };
password $config->{password};
poco_irc_args(UseSSL => 1);

my $WKSP_ID = $config->{workspace};
my $LP_BASE = "https://app.liquidplanner.com/api/workspaces/$WKSP_ID";
my $CIRC_BASE = "https://api.circonus.com/";

has phone_book => (
  isa => 'HashRef',
  traits  => [ 'Hash' ],
  default => sub { $config->{phone_book} },
  reader  => '_phone_book',
  handles => { phone_for_username => 'get' },
);

has reverse_phone_book => (
  isa  => 'HashRef',
  lazy => 1,
  traits  => [ 'Hash' ],
  default => sub { my %hash = reverse %{ $_[0]->_phone_book }; \%hash },
  handles => { username_for_phone => 'get' },
);

use constant {
  TIME_WEEKEND  => -1,  # Working on the weekend!
  TIME_BIZ_SAFE =>  0,  # Should absolutely be working.
  TIME_BIZ_REAL =>  1,  # Real work hours.
  TIME_EARLY    =>  2,  # Definitely early.
  TIME_LATE     =>  3,  # Definitely late.
};

has chilltill => (
  is  => 'rw',
  isa => 'Int',
  predicate => 'has_chilltill',
  clearer   => 'clear_chilltill',
);

has httpd => (
  is => 'bare',
  builder => '_build_httpd',
);

has httpd_port => (is => 'ro', lazy => 1, default => 8118);

sub resolve_name {
  my ($self, $name, $who) = @_;
  return $who if lc $name eq 'me';
  return $who if lc $name eq 'myself';

  return $config->{nicknames}{lc $name} if $config->{nicknames}{lc $name};
  return lc $name;
}

sub START {
  my ($self, $kernel) = @_[ OBJECT, KERNEL ];
  $kernel->alias_set('Synergy');
}

sub _build_httpd {
  my ($self) = @_;
  my $session_id = $self->get_session_id;

  POE::Component::Server::SimpleHTTP->new(
    ALIAS   => 'httpd',
    ADDRESS => 0,
    PORT    => $self->httpd_port,
    HANDLERS => [
      {
        DIR => '^/sms$',
        SESSION => 'Synergy',
        EVENT => '_http_sms',
      },
      {
        DIR => '^/alert.json$',
        SESSION => 'Synergy',
        EVENT => '_http_alert',
      },
      {
        DIR => '.*',
        SESSION => 'Synergy',
        EVENT => '_http_404',
      },
    ],
    HEADERS => { Server => 'Synergy' },
  );
}

event _http_alert => sub {
  my ($kernel, $self, $request, $response) = @_[ KERNEL, OBJECT, ARG0 .. ARG1 ];

  # Check for errors
  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  my $json = $request->content;

  if ($json =~ /%20/) { # stupid check for not-json because circonus seems buggy
    my $param = $self->_params_from_req($request);
    $json = "(faked up) - " . JSON->new->encode($param);
  }

  $kernel->call( 'httpd', 'DONE', $response );

  $response->code(204);

  $self->privmsg(
    $self->get_channels->[0],
    "circonus alert: $json",
  );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub _params_from_req {
  my ($self, $req) = @_;

  my $body = HTTP::Body->new(
    scalar $req->header('Content-Type'),
    scalar $req->header('Content-Length'),
  );
  $body->add( $req->content );

  return $body->param;
}

event _http_sms => sub {
  my ($kernel, $self, $request, $response, $dirmatch)
    = @_[ KERNEL, OBJECT, ARG0 .. ARG2 ];

  # Check for errors
  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  my $param = $self->_params_from_req($request);

  my $from = $param->{From} // '';
  $from =~ s/\A\+1//;

  my $who = $self->username_for_phone($from);
  unless ($param->{AccountSid} eq $config->{twilio_sid} and $who) {
    $response->code(400);
    $response->content("Bad request");
    $kernel->call( 'httpd', 'DONE', $response );
    $self->info(sprintf "Bad request for %s from phone %s from IP %s",
      $request->uri->path_query,
      $from,
      $response->connection->remote_ip,
    );
    return;
  }

  my $text = $param->{Body};

  my $reply;
  my $result = $self->_dispatch({
    how   => \$reply,
    who   => $who,
    where => [ $from ],
    what  => $text,
  });

  if ($result && $result eq -1) {
    $response->code(200);
    $response->content("Does not compute.");
  } else {
    $response->code(200);
    $response->content($reply);
  }

  $kernel->call( 'httpd', 'DONE', $response );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub SAID_announce {
  my ($self, $arg) = @_;

  if ($arg->{how} eq 'irc') {
    return $self->reply(
      "Asking me to say something on IRC when you're on IRC is weird.",
      $arg,
    );
  }

  my $what = $arg->{what} =~ s/\Athat:? //r;

  $self->privmsg(
    $self->get_channels->[0],
    "$arg->{who} says: $what",
  );

  $self->reply("Message relayed", $arg);
}

event _http_404 => sub {
  my ($kernel, $self, $request, $response) = @_[ KERNEL, OBJECT, ARG0 .. ARG2 ];

  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  # Do our stuff to HTTP::Response
  $response->code(404);
  $response->content( "Hi visitor from " . $response->connection->remote_ip . ", Page not found -> '" . $request->uri->path . "'\n\n" );

  # We are done!
  # For speed, you could use $_[KERNEL]->call( ... )
  $kernel->call( 'httpd', 'DONE', $response );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub chilling {
  my ($self) = @_;
  return unless $self->has_chilltill;
  return time <= $self->chilltill;
}

sub is_showtime {
  my ($self) = @_;
  return if $self->chilling;
  return 1 if $self->showtime_is_set_manually;
  $self->clear_showtime, return 1 if $self->is_business_hours;
  return;
}

has showtime => (
  isa => 'Bool',
  traits  => [ 'Bool' ],
  handles => { start_showtime => 'set' },
  reader  => 'showtime_is_set_manually',
  clearer => 'clear_showtime',
);

sub is_business_hours {
  my ($self) = @_;
  my @time = localtime;

  # Weekends off.
  return if $time[6] == 0 or $time[6] == 6;

  # Nagging starts at 10:30
  return if $time[2] <  10
         or $time[2] == 10 && $time[1] < 30;
  #
  # Nagging ends at 17:00
  return if $time[2] >  16;

  return 1;
}

sub __hs { $_[0] * 3600 + $_[1] * 60 }

sub _classify_now {
  my ($self) = @_;
  my @time = localtime;

  # Weekends off.
  return TIME_WEEKEND if $time[6] == 0 or $time[6] == 6;

  my $daysecs = $time[0]
              + $time[1] * 60
              + $time[2] * 3600;

  return TIME_BIZ_SAFE if $daysecs >= __hs(10,30) && $daysecs <= __hs(17,00);

  return TIME_BIZ_REAL if $daysecs >= __hs( 9,00) && $daysecs <= __hs(17,30);

  return TIME_LATE  if $daysecs >= __hs(17,30);
  return TIME_LATE  if $daysecs <= __hs( 3,00);
  return TIME_EARLY;
}

has last_nag => (
  is  => 'rw',
  predicate => 'has_last_nag',
  clearer   => 'clear_last_nag',
);

sub sms {
  my ($self, $number, $msg) = @_;

  my $ua = LWP::UserAgent::POE->new;
  my $res = $ua->post(
    "https://api.twilio.com/2010-04-01/Accounts/$config->{twilio_sid}/SMS/Messages",
    {
      From => $config->{twilio_from},
      To   => $number,
      Body => $msg,
    },
    Authorization => "Basic $config->{twilio_auth}",
  );
}

sub last_relevant_nag {
  my ($self) = @_;

  # If we had nagged, but haven't nagged in 45 minutes, let's start over.
  # This could happen, for example, if we were nagging at the end of the
  # business day and now it's morning, or if we were at high-severity nagging
  # before getting told to chill. -- rjbs, 2014-01-15
  my $last_nag = $self->last_nag;
  if ($last_nag and time - $last_nag->{time} > 2700) {
    $self->info("It's been >45min since last nag.  Resetting nag state.");
    $self->clear_last_nag;
    return undef;
  }

  return $last_nag;
}

event nag => sub {
  my ($self) = $_[OBJECT];

  $self->info("considering nagging and setting up next nag");

  $self->delay(nag => 300);

  my $last_nag = $self->last_relevant_nag;

  if ($self->is_showtime) {
    my $timer = $self->current_timer;

    if ($timer && $timer == -1) { warn "error retrieving timer\n"; return };
    if ($timer) {
      $self->info("We're good: there's a timer.");

      if ($timer->{running_time} > 3 * 3600) {
        if ($last_nag && time - $last_nag->{time} < 900) {
          $self->info("Won't nag, nagged within the last 15min.");
          return;
        }

        $self->sms(
          $config->{master_ph},
          "Your timer has been running for "
          . concise(duration($timer->{running_time}))
          . ".  Maybe you should commit your work."
        );
        $self->last_nag({ time => time, level => 0 });
        return;
      }

      $self->clear_last_nag;
      return;
    }

    my $level = 0;
    if ($last_nag) {
      if (time - $last_nag->{time} < 900) {
        $self->info("Won't nag, nagged within the last 15min.");
        return;
      }
      $level = $last_nag->{level} + 1;
    }

    if ($level < 2) {
      my $still = $level == 0 ? '' : ' still';
      $self->privmsg(
        $config->{master},
        "Your LiquidPlanner timer$still isn't running",
      );
      $self->last_nag({ time => time, level => $level });
    } else {
      $self->sms($config->{master_ph}, "Your LiquidPlanner timer isn't running.");
      $self->last_nag({ time => time, level => $level });
    }
  }
};

sub current_timer {
  my ($self) = @_;

  my $ua = $self->lp_ua;
  my $res = $ua->get("$LP_BASE/my_timers");
  return -1 unless $res->is_success;

  my ($timer) = grep {; $_->{running} }
                @{ $JSON->decode( $res->decoded_content ) };

  return $timer;
}

event irc_bot_addressed => sub {
  my ($self, $nickstr, $channel, $msg) = @_[ OBJECT, ARG0, ARG1, ARG2 ];
  my ($nick) = split /!/, $nickstr;

  my $result = $self->_dispatch({
    how   => 'irc',
    who   => $nick,
    where => $channel,
    what  => $msg,
  });

  return unless $result && $result == -1;

  $self->privmsg( $channel => "$nick: Does not compute." );
};

my %ALIAS = (
  say  => 'announce',
  '++' => 'plusplus',
  new  => 'task',
);

sub _dispatch {
  my ($self, $arg) = @_;

  my $msg = $arg->{what};
  my ($cmd, $rest) = split ' ', $msg, 2;

  # First pass before stripping things down to alnum.
  $cmd = $ALIAS{$cmd} if $ALIAS{$cmd};

  $cmd =~ tr/[A-Za-z0-9]//dc;
  $cmd = lc $cmd;

  # Second pass for alnum aliases.
  $cmd = $ALIAS{$cmd} if $ALIAS{$cmd};

  my $method = "SAID_$cmd";
  $self->info("looking to call ->$method(" . ($rest // '') . ")");

  my %public = map {; $_ => 1 } qw(page task remind alerts ack);

  return -1 unless $self->can("SAID_$cmd");

  unless ($public{$cmd} or $arg->{who} eq $config->{master}) {
    return $self->reply("Only $config->{master} can do that.", $arg);
  }

  return $self->$method({ %$arg, what => $rest });
}

sub reply {
  my ($self, $reply, $arg) = @_;

  if ($arg->{how} eq 'sms') {
    $self->sms($arg->{where}[0], $reply);
  } elsif (ref $arg->{how} eq 'SCALAR') {
    ${ $arg->{how} } = $reply;
  } else {
    $self->privmsg($arg->{where}, "$arg->{who}: $reply");
  }
}

sub SAID_showtime {
  my ($self, $arg) = @_;

  if ($self->has_chilltill and $self->chilltill > time) {
    if ($self->is_business_hours) {
      $self->reply("Okay, back to work!", $arg);
    } else {
      $self->reply("Back to normal business hours, then.", $arg);
    }
  } elsif ($self->is_business_hours) {
    $self->reply("I thought it was already showtime!", $arg);
  } else {
    $self->start_showtime;
    return $self->reply("Okay, business hours extended!", $arg);
  }

  $self->clear_chilltill;
  return;
}

sub SAID_shows {
  my ($self, $arg) = @_;
  return $self->SAID_chill({ %$arg, what => 'until tomorrow' })
    if $arg->{what} eq 'over';
  return -1;
}

has _date_parser => (
  is => 'ro',
  default => sub {
    DateTime::Format::Natural->new(
      prefer_future => 1,
      time_zone     => 'America/New_York',
    );
  },
);

sub SAID_chill {
  my ($self, $arg) = @_;
  my ($prep, $rest) = split ' ', $arg->{what}, 2;

  my $time;
  if ($prep eq 'for') {
    my $dur;
    $rest =~ s/^an?\s+/1 /;
    my $ok = eval { $dur = parse_duration($rest); 1 };
    return -1 unless $ok;
    $time = time + $dur;
  } elsif ($prep eq 'until') {
    my $dt = eval { $self->_date_parser->parse_datetime($rest) };
    return -1 unless $dt;
    $time = $dt->epoch;
  } else {
    return -1;
  }

  if ($time <= time) {
    $self->reply("That sounded like you want to chill until the past.", $arg);
    return;
  }

  $self->chilltill($time);
  $self->reply("Okay, no more nagging until " . localtime $time, $arg);
}

sub SAID_remind {
  my ($self, $arg) = @_;

  my ($who, $prep, $dur_str, $rest) = $arg->{what} =~ qr/\A
    \s*
    (\S+)    # "me" or a nick
    \s+
    (in|at) # duration type
    \s+
    (.+?)    # duration
    :\s+     # the space is vital:  "at 15:15: eat pie"
    (.+)     # the reminder
    \z
  /x;

  unless (length $who) {
    $self->warn("couldn't parse <<$arg->{what}>>");
    return -1;
  }

  $who = $self->resolve_name($who, $arg->{who});

  my $time;
  if ($prep eq 'in') {
    my $dur;
    $dur_str =~ s/^an?\s+/1 /;
    my $ok = eval { $dur = parse_duration($dur_str); 1 };
    return -1 unless $ok;
    $time = time + $dur;
  } elsif ($prep eq 'at') {
    my $dt = eval { $self->_date_parser->parse_datetime($dur_str) };
    return -1 unless $dt;
    $time = $dt->epoch;
  } else {
    return -1;
  }

  if ($time <= time) {
    $self->reply("That sounded like you want a reminder sent in the past.", $arg);
    return;
  }

  my $target = $who eq $arg->{who} ? 'you' : $who;

  $self->alarm_add(
    send_reminder => $time,
    { %$arg, who => $who },
    DateTime->now(time_zone => 'America/New_York'),
    $rest,
  );
  $self->reply("Okay, I'll remind $target at " . localtime $time, $arg);
}

event send_reminder => sub {
  my ($self, $reply_arg, $requested_time, $msg) = @_[OBJECT, ARG0..ARG2];
  $self->reply("Reminder from $requested_time: $msg", $reply_arg);
};

sub SAID_abort {
  my ($self, $arg) = @_;

  if ($arg->{what} eq 'timer') {
    my $ua = $self->lp_ua;
    my $res = $ua->get("$LP_BASE/my_timers");

    return $self->reply("Something went wrong", $arg) unless $res->is_success;

    my ($timer) = grep {; $_->{running} }
                  @{ $JSON->decode( $res->decoded_content ) };

    unless ($timer) {
      $self->reply("You don't have an active timer to abort.", $arg);
      return;
    }

    my $stop_res = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/stop");
    my $clr_res  = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/clear");

    if ($stop_res->is_success and $clr_res->is_success) {
      $self->clear_last_nag;
      $self->reply("Okay, I stopped and cleared your active timer.", $arg);
    } else {
      $self->reply("Something went wrong aborting your timer.", $arg);
    }
  } else {
    $self->reply("I didn't understand your abort request.", $arg);
  }
}

sub SAID_pause {
  my ($self, $arg) = @_;

  if ($arg->{what} eq 'timer') {
    my $ua = $self->lp_ua;
    my $res = $ua->get("$LP_BASE/my_timers");

    return $self->reply("Something went wrong", $arg) unless $res->is_success;

    my ($timer) = grep {; $_->{running} }
                  @{ $JSON->decode( $res->decoded_content ) };

    my $stop_res = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/stop");
    unless ($stop_res->is_success) {
      return $self->reply("I couldn't pause your active timer.", $arg);
    }

    $self->clear_last_nag;
    $self->reply("Okay, I paused your active timer.", $arg);
  } else {
    $self->reply("I didn't understand your pause request.", $arg);
  }
}

has lp_ua => (
  is => 'ro',
  lazy    => 1,
  default => sub {
    my $ua = LWP::UserAgent::POE->new(keep_alive => 1);
    my $token = $config->{lp_token};

    $ua->default_header('Authorization' => "$token");
    return $ua;
  },
);

has cir_ua => (
  is => 'ro',
  lazy    => 1,
  default => sub {
    my $ua = LWP::UserAgent::POE->new(keep_alive => 1);
    my $token = $config->{circonus_token};

    $ua->default_header('X-Circonus-App-Name' => 'Synergy');
    $ua->default_header('X-Circonus-Auth-Token' => $token);
    $ua->default_header('Accept' => "application/json");

    return $ua;
  },
);
sub SAID_status {
  my ($self, $arg) = @_;

  my $ua = $self->lp_ua;
  my $res = $ua->get("$LP_BASE/my_timers");

  unless ($res->is_success) {
    $self->reply("I couldn't get your timer.", $arg);
    warn $res->as_string;
    return;
  }

  my @timers = grep {; $_->{running} }
               @{ $JSON->decode( $res->decoded_content ) };

  unless (@timers) {
    my $nag = $self->last_relevant_nag;
    my $msg;
    if (! $nag) {
      $msg = "You don't have a running timer.";
    } elsif ($nag->{level} == 0) {
      $msg = "Like I said, you don't have a running timer.";
    } else {
      $msg = "Like I keep telling you, you don't have a running timer!";
    }

    return $self->reply($msg, $arg);
  }

  if (@timers > 1) {
    $self->reply(
      "Woah.  LiquidPlanner says you have more than one active timer!",
      $arg,
    );
  }

  my $timer = $timers[0];
  my $time = concise( duration( $timer->{running_time} * 3600 ) );
  my $task_res = $ua->get("$LP_BASE/tasks/$timer->{item_id}");

  my $name = $task_res->is_success
           ? $JSON->decode($task_res->decoded_content)->{name}
           : '??';

  $self->reply("Your timer has been running for $time, work on: $name", $arg);
}

sub SAID_plusplus {
  my ($self, $arg) = @_;

  return $self->SAID_task({
    %$arg,
    what => "for $arg->{who}: $arg->{what}",
  });
}

sub SAID_alerts {
  my ($self, $arg) = @_;
  my $ua = $self->cir_ua;

  my $res = $ua->get("$CIRC_BASE/alert");
  my $json = $res->decoded_content;
  my $alerts = decode_json($json);
  if (@$alerts[0]){
    for my $event (@$alerts) {
      warn Dumper($event);
      my $response = $event->{_cid}, $event->{_check_name}, $event->{_alert_url};
      $self->reply($response, $arg);
    }
  } else {
    $self->reply("nothing alerting", $arg);
  }
}

sub SAID_ack {
  my ($self, $arg) = @_;

  my ($alert_id, $for, $period) = split(/ /, $arg->{what});

  warn "alert id $alert_id for period $period\n";

  return $self->reply("Alert ids are numbers only.", $arg)
    unless $alert_id =~ /\A[0-9]+\z/;
  return $self->reply("Ack in minutes, hours, or days. (ex: 15m)", $arg)
    unless $period =~ /\A[0-9]+[hmd]\z/;

  my $content = encode_json({
      'acknowledged_until' => "$period",
      'alert'              => "/alert/$alert_id",
    });
  my $ua = $self->cir_ua;
  my $check = $ua->get("$CIRC_BASE/alert/$alert_id");
  if ($check->{_rc} == 200) {
    my $res = $ua->post(
      "$CIRC_BASE/acknowledgement", 
      Content => $content); 
    my $json = $res->decoded_content;
    return $self->reply("Alert $alert_id acked for $period", $arg);
  } else {
    return $self->reply(
    "ID $alert_id is not valid. Try 'alerts' to see open alerts.", 
    $arg);
  }
}

sub SAID_task {
  my ($self, $arg) = @_;

  # because of "new task for...";
  my $what = $arg->{what} =~ s/\Atask\s+//r;

  my ($target, $name) = $what =~ /\s*for\s+(\S+?):?\s+(.+)\z/;
  $target = $self->resolve_name($target, $arg->{who});

  my $owner_id;
  unless ($owner_id = $config->{lp_members}{$target}) {
    return $self->reply("I don't know who $target is.", $arg);
  }

  my $urgent = $name =~ s/\s*\(!+\)\s*\z//;

  my $payload = { task => {
    name     => $name,
    owner_id => $owner_id,
    ($urgent ? (parent_id => $config->{lp_urgent}) : ()),
    description => "created by " . $self->get_nickname . " on $arg->{where}[0] "
                .  "on behalf of $arg->{who}",
  } };

  my $res = $self->lp_ua->post(
    "$LP_BASE/tasks",
    Content_Type => 'application/json',
    Content => $JSON->encode($payload),
  );

  unless ($res->is_success) {
    warn ">>" . $res->decoded_content . "<<";
    warn $res->as_string;
    return $self->reply(
      "Sorry, something went wrong when I tried to make that task.",
      $arg,
    );
  }

  $self->reply(
    sprintf(
      "Task for $target created: https://app.liquidplanner.com/space/%s/projects/show/%s",
      $config->{workspace},
      $JSON->decode($res->decoded_content)->{id},
    ),
    $arg,
  );
}

sub SAID_page {
  my ($self, $arg) = @_;
  $arg->{what} =~ s/\A\s+//;
  $arg->{what} =~ s/\s+\z//;

  if ($arg->{what} =~ /\A(\w+)[.?!]*\z/) {
    my $who   = $self->resolve_name("$1", $arg->{who});
    my $phone = $self->phone_for_username($who);

    unless ($phone) {
      return $self->reply("I don't have a number for $who.", $arg);
    }

    $self->sms($phone, "$arg->{who} just paged you on @{ $arg->{where} }");
    $self->reply("Okay, I sent a page.", $arg);
    return;
  }

  my ($who, $rest) = split /\s*:\s*/, $arg->{what}, 2;
  $who = $self->resolve_name($who, $arg->{who});

  unless ($arg->{what} and $arg->{what} =~ /\S/) {
    return $self->reply(
      "It goes:  <<page whoever>> or <<page whoever: message>>",
      $arg,
    );
  }

  my $phone = $self->phone_for_username($who);
  unless ($phone) {
    return $self->reply("I don't have a number for $who.", $arg);
  }

  $self->sms(
    $phone,
    "$arg->{who} just paged you on @{ $arg->{where} }: $rest",
  );
  $self->reply("Okay, I sent a page.", $arg);
  return;
}

sub SAID_whats {
  my ($self, $arg) = @_;
  return $self->SAID_what({ %$arg, what => "is $arg->{what}" });
}

sub SAID_what {
  my ($self, $arg) = @_;
  my $what = $arg->{what};
  $what =~ s/\s+\?*//;
  return -1 unless $what =~ s/\Ais //;
  return -1 unless $what =~ /\Ayour (?:phone )?number\z/;

  my ($c, $ac, $ex, $rest) = $config->{twilio_from} =~ m{
    ([0-9]) ([0-9]{3}) ([0-9]{3}) ([0-9]{4})
  }x;

  my $num = "+$c $ac $ex-$rest";
  $self->reply("You can text me at $num.", $arg);
}

sub BUILD {
  my ($self) = @_;

  $self->delay(nag => 60, qw(foo bar baz));
}

__PACKAGE__->run;
