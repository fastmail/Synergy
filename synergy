#!perl
use 5.16.0;
package Synergy;
use Moses;
use namespace::autoclean;

use DateTime::Format::Natural;
use HTTP::Body;
use JSON 2 ();
use LWP::UserAgent::POE;
use MIME::Base64;
use POE::Component::Server::SimpleHTTP;
use Time::Duration::Parse;
use Time::Duration;
use YAML::XS;

my $JSON = JSON->new;

die "no config file" unless -e $ENV{SYNERGY_CONFIG};
my $config = YAML::XS::LoadFile($ENV{SYNERGY_CONFIG});

server   $config->{server};
nickname $config->{nickname};
username $config->{username};
channels @{ $config->{channels} };
password $config->{password};
poco_irc_args(UseSSL => 1);

my $WKSP_ID = $config->{workspace};
my $LP_BASE = "https://app.liquidplanner.com/api/workspaces/$WKSP_ID";
my $CIRC_BASE = "https://api.circonus.com";

has phone_book => (
  isa => 'HashRef',
  lazy    => 1,
  traits  => [ 'Hash' ],
  default => sub { $config->{phone_book} },
  reader  => '_phone_book',
  clearer => '_clear_phone_book',
  handles => { phone_for_username => 'get' },
);

has reverse_phone_book => (
  isa  => 'HashRef',
  lazy => 1,
  traits  => [ 'Hash' ],
  default => sub { my %hash = reverse %{ $_[0]->_phone_book }; \%hash },
  clearer => '_clear_reverse_phone_book',
  handles => { username_for_phone => 'get' },
);

has circ_book => (
  isa => 'HashRef',
  lazy    => 1,
  traits  => [ 'Hash' ],
  default => sub { $config->{circ_members} },
  reader  => '_circ_book',
  clearer => '_clear_circ_book',
  handles => { circ_id_for_username => 'get' },
);

has reverse_circ_book => (
  isa  => 'HashRef',
  lazy => 1,
  traits  => [ 'Hash' ],
  default => sub { my %hash = reverse %{ $_[0]->_circ_book }; \%hash },
  clearer => '_clear_reverse_circ_book',
  handles => { username_for_circ_id => 'get' },
);

use constant {
  TIME_WEEKEND  => -1,  # Working on the weekend!
  TIME_BIZ_SAFE =>  0,  # Should absolutely be working.
  TIME_BIZ_REAL =>  1,  # Real work hours.
  TIME_EARLY    =>  2,  # Definitely early.
  TIME_LATE     =>  3,  # Definitely late.
};

has chilltill => (
  is  => 'rw',
  isa => 'Int',
  predicate => 'has_chilltill',
  clearer   => 'clear_chilltill',
);

has _recent_alerts => (
  is  => 'ro',
  default => sub {  {}  },
);

sub recent_alerts {
  my ($self) = @_;
  my $stash = $self->_recent_alerts;
  my $now = time;
  for my $key (keys %$stash) {
    delete $stash->{$key} if $now - $stash->{$key}{recorded_at} > 15*60;
  }

  return $stash;
}

sub record_alerts {
  my ($self, $alerts) = @_;

  my $now   = time;
  my $stash = $self->recent_alerts;

  for my $alert (@$alerts) {
    $stash->{ $alert->{alert_id} } = {
      recorded_at => $now,
      metric_name => $alert->{metric_name},
      host        => $alert->{host},
      check_id    => $alert->{check_id},
    };
  }

  return;
}

has suppress_alerts_until => (
  is  => 'rw',
  isa => 'Int',
  predicate => 'has_suppress_alerts_until',
  clearer   => 'clear_suppress_alerts_until',
);

has httpd => (
  is => 'bare',
  builder => '_build_httpd',
);

has httpd_port => (is => 'ro', lazy => 1, default => 8118);

sub resolve_name {
  my ($self, $name, $who) = @_;
  return $who if lc $name eq 'me';
  return $who if lc $name eq 'my';
  return $who if lc $name eq 'myself';

  return $config->{nicknames}{lc $name} if $config->{nicknames}{lc $name};
  return lc $name;
}

sub START {
  my ($self, $kernel) = @_[ OBJECT, KERNEL ];
  $kernel->alias_set('Synergy');
}

sub _build_httpd {
  my ($self) = @_;
  my $session_id = $self->get_session_id;

  POE::Component::Server::SimpleHTTP->new(
    ALIAS   => 'httpd',
    ADDRESS => 0,
    PORT    => $self->httpd_port,
    HANDLERS => [
      {
        DIR => '^/sms$',
        SESSION => 'Synergy',
        EVENT => '_http_sms',
      },
      {
        DIR => '^/alert.json$',
        SESSION => 'Synergy',
        EVENT => '_http_alert',
      },
      {
        DIR => '.*',
        SESSION => 'Synergy',
        EVENT => '_http_404',
      },
    ],
    HEADERS => { Server => 'Synergy' },
  );
}

event _http_alert => sub {
  my ($kernel, $self, $request, $response) = @_[ KERNEL, OBJECT, ARG0 .. ARG1 ];

  # Check for errors
  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  my @msgs;

  my $json = $request->content;
  warn "CIRCONUS: $json\n";
  # {
  #   "alerts": [
  #     {"check_name":"pb-wm1.int.icgroup.com basic","metric_link":null,"check_id":96848,"alert_value":null,"check_bundle_id":73559,"alert_url":"https://circonus.com/account/ic-group-inc/fault-detection?alert_id=19039695","host":"pb-wm1.int.icgroup.com","metric_notes":null,"alert_time":"Sun, 22 Mar 2015 20:01:02","clear_time":"Sun, 22 Mar 2015 20:07:22","metric_name":"service|-faults","clear_value":"0.0","agent":"Quonix","severity":"1","alert_id":"19039695"}
  #   ],
  #   "account_name":"IC Group, INC"
  # }

  my $data = eval { $JSON->decode($json); };

  if ($data) {
    for my $alert (@{ $data->{alerts} }) {
      push @msgs, $self->_fmt_alert($alert);
    }
  } else {
    @msgs = ("Error decoding <$json>: $@");
  }

  $kernel->call( 'httpd', 'DONE', $response );

  $response->code(204);

  if ($self->has_suppress_alerts_until && time < $self->suppress_alerts_until) {
    $self->info("Declining to relay alerts during suppression period.");
  } else {
    # We only record the alerts when we mention them, because otherwise it
    # might be weird to see no alerts, then "ack all those" doing something.
    # -- rjbs, 2015-03-23
    $self->record_alerts($data->{alerts});
    for my $msg (@msgs) {
      $self->privmsg(
        $self->get_channels->[0],
        $msg,
      );
    }
  }

  $self->info(
    sprintf "Request from %s: %s",
      $response->connection->remote_ip,
      $request->uri->path_query
  );
};

sub _fmt_alert {
  my ($self, $alert) = @_;

  my $type   = $alert->{clear_time} ? 'recovery' : 'alert';
  $type .= "-$alert->{severity}" unless $alert->{clear_time};

  my $metric = $alert->{metric_name}
             . ($alert->{metric_notes} ? " ($alert->{metric_notes})" : '');

  sprintf 'Circonus alert %u: [%s] %s / %s <%s>',
    $alert->{alert_id},
    uc $type,
    $alert->{check_name},
    $metric,
    $alert->{alert_url};
}

sub _params_from_req {
  my ($self, $req) = @_;

  my $body = HTTP::Body->new(
    scalar $req->header('Content-Type'),
    scalar $req->header('Content-Length'),
  );
  $body->add( $req->content );

  return $body->param;
}

event _http_sms => sub {
  my ($kernel, $self, $request, $response, $dirmatch)
    = @_[ KERNEL, OBJECT, ARG0 .. ARG2 ];

  # Check for errors
  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  my $param = $self->_params_from_req($request);

  my $from = $param->{From} // '';
  $from =~ s/\A\+1//;

  my $who = $self->username_for_phone($from);
  unless ($param->{AccountSid} eq $config->{twilio_sid} and $who) {
    $response->code(400);
    $response->content("Bad request");
    $kernel->call( 'httpd', 'DONE', $response );
    $self->info(sprintf "Bad request for %s from phone %s from IP %s",
      $request->uri->path_query,
      $from,
      $response->connection->remote_ip,
    );
    return;
  }

  my $text = $param->{Body};

  my $reply;
  my $result = $self->_dispatch({
    how   => \$reply,
    who   => $who,
    where => [ $from ],
    what  => $text,
  });

  if ($result && $result eq -1) {
    $response->code(200);
    $response->content("Does not compute.");
  } else {
    $response->code(200);
    $response->content($reply);
  }

  $kernel->call( 'httpd', 'DONE', $response );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub SAID_eject {
  my ($self, $arg) = @_;
  return -1 unless $arg->{what} eq 'warp core';
  kill 'INT', $$;
}

sub SAID_announce {
  my ($self, $arg) = @_;

  if ($arg->{how} eq 'irc') {
    return $self->reply(
      "Asking me to say something on IRC when you're on IRC is weird.",
      $arg,
    );
  }

  my $what = $arg->{what} =~ s/\Athat:? //r;

  $self->privmsg(
    $self->get_channels->[0],
    "$arg->{who} says: $what",
  );

  $self->reply("Message relayed", $arg);
}

event _http_404 => sub {
  my ($kernel, $self, $request, $response) = @_[ KERNEL, OBJECT, ARG0 .. ARG2 ];

  if (! defined $request) {
    $kernel->call('httpd', 'DONE', $response );
    return;
  }

  # Do our stuff to HTTP::Response
  $response->code(404);
  $response->content( "Hi visitor from " . $response->connection->remote_ip . ", Page not found -> '" . $request->uri->path . "'\n\n" );

  # We are done!
  # For speed, you could use $_[KERNEL]->call( ... )
  $kernel->call( 'httpd', 'DONE', $response );

  $self->info("Request from " . $response->connection->remote_ip . " " . $request->uri->path_query);
};

sub chilling {
  my ($self) = @_;
  return unless $self->has_chilltill;
  return time <= $self->chilltill;
}

sub is_showtime {
  my ($self) = @_;
  return if $self->chilling;
  return 1 if $self->showtime_is_set_manually;
  $self->clear_showtime, return 1 if $self->is_business_hours;
  return;
}

has showtime => (
  isa => 'Bool',
  traits  => [ 'Bool' ],
  handles => { start_showtime => 'set' },
  reader  => 'showtime_is_set_manually',
  clearer => 'clear_showtime',
);

sub is_business_hours {
  my ($self) = @_;
  my @time = localtime;

  # Weekends off.
  return if $time[6] == 0 or $time[6] == 6;

  # Nagging starts at 10:30
  return if $time[2] <  10
         or $time[2] == 10 && $time[1] < 30;
  #
  # Nagging ends at 17:00
  return if $time[2] >  16;

  return 1;
}

sub __hs { $_[0] * 3600 + $_[1] * 60 }

sub _classify_now {
  my ($self) = @_;
  my @time = localtime;

  # Weekends off.
  return TIME_WEEKEND if $time[6] == 0 or $time[6] == 6;

  my $daysecs = $time[0]
              + $time[1] * 60
              + $time[2] * 3600;

  return TIME_BIZ_SAFE if $daysecs >= __hs(10,30) && $daysecs <= __hs(17,00);

  return TIME_BIZ_REAL if $daysecs >= __hs( 9,00) && $daysecs <= __hs(17,30);

  return TIME_LATE  if $daysecs >= __hs(17,30);
  return TIME_LATE  if $daysecs <= __hs( 3,00);
  return TIME_EARLY;
}

has last_nag => (
  is  => 'rw',
  predicate => 'has_last_nag',
  clearer   => 'clear_last_nag',
);

sub sms {
  my ($self, $number, $msg) = @_;

  my $ua = LWP::UserAgent::POE->new;
  my $res = $ua->post(
    "https://api.twilio.com/2010-04-01/Accounts/$config->{twilio_sid}/SMS/Messages",
    {
      From => $config->{twilio_from},
      To   => $number,
      Body => $msg,
    },
    Authorization => "Basic $config->{twilio_auth}",
  );
}

sub last_relevant_nag {
  my ($self) = @_;

  # If we had nagged, but haven't nagged in 45 minutes, let's start over.
  # This could happen, for example, if we were nagging at the end of the
  # business day and now it's morning, or if we were at high-severity nagging
  # before getting told to chill. -- rjbs, 2014-01-15
  my $last_nag = $self->last_nag;
  if ($last_nag and time - $last_nag->{time} > 2700) {
    $self->info("It's been >45min since last nag.  Resetting nag state.");
    $self->clear_last_nag;
    return undef;
  }

  return $last_nag;
}

event nag => sub {
  my ($self) = $_[OBJECT];

  $self->info("considering nagging and setting up next nag");

  $self->delay(nag => 300);

  my $last_nag = $self->last_relevant_nag;

  my $timer = $self->current_timer;
  if ($timer && $timer == -1) { warn "error retrieving timer\n"; return };

  { # Timer running too long!
    if ($timer && $timer->{running_time} > 3) {
      if ($last_nag && time - $last_nag->{time} < 900) {
        $self->info("Won't nag, nagged within the last 15min.");
        return;
      }

      $self->sms(
        $self->phone_for_username($config->{master}),
        "Your timer has been running for "
        . concise(duration($timer->{running_time} * 3600))
        . ".  Maybe you should commit your work."
      );
      $self->last_nag({ time => time, level => 0 });
      return;
    }
  }

  if ($self->is_showtime) {
    if ($timer) {
      $self->info("We're good: there's a timer.");

      $self->clear_last_nag;
      return;
    }

    my $level = 0;
    if ($last_nag) {
      if (time - $last_nag->{time} < 900) {
        $self->info("Won't nag, nagged within the last 15min.");
        return;
      }
      $level = $last_nag->{level} + 1;
    }

    my $still = $level == 0 ? '' : ' still';
    my $msg   = "Your LiquidPlanner timer$still isn't running";
    $self->privmsg($config->{master}, $msg);
    if ($level >= 2) {
      $self->sms($config->{master_ph}, $msg);
    }
    $self->last_nag({ time => time, level => $level });
  }
};

sub current_timer {
  my ($self) = @_;

  my $ua = $self->lp_ua;
  my $res = $ua->get("$LP_BASE/my_timers");
  return -1 unless $res->is_success;

  my ($timer) = grep {; $_->{running} }
                @{ $JSON->decode( $res->decoded_content ) };

  return $timer;
}

event irc_msg => sub {
  my ($self, $nickstr, $msg) = @_[ OBJECT, ARG0, ARG2 ];
  my ($nick) = split /!/, $nickstr;

  my $me = $self->get_nickname;
  $msg =~ s/\A \s* [@%]? \Q$me\E \s* (?: [,:] \s+)?//ix;

  my $result = $self->_dispatch({
    how   => 'irc',
    who   => $nick,
    where => $nick,
    what  => $msg,
  });

  return unless $result && $result == -1;

  $self->privmsg( $nick => "$nick: Does not compute." );
};

event irc_bot_addressed => sub {
  my ($self, $nickstr, $channel, $msg) = @_[ OBJECT, ARG0, ARG1, ARG2 ];
  my ($nick) = split /!/, $nickstr;

  my $result = $self->_dispatch({
    how   => 'irc',
    who   => $nick,
    where => $channel,
    what  => $msg,
  });

  return unless $result && $result == -1;

  $self->privmsg( $channel => "$nick: Does not compute." );
};

has last_msgs => (
  is => 'ro',
  init_arg => undef,
  default  => sub {  {}  },
);

my %ALIAS = (
  say  => 'announce',
  '++' => 'plusplus',
  new  => 'task',
);

sub _dispatch {
  my ($self, $arg) = @_;

  my $msg = $arg->{what};

  my $last_ref = ref $arg->{how}
               ? \do { my $x }
               : \($self->last_msgs->{ $arg->{who} }->{ $arg->{how} });

  if ($msg eq 'commit that') {
    return "Sorry, I don't see a previous message from you." unless $$last_ref;
    local $arg->{what} = "commit: $$last_ref";
    return $self->_dispatch($arg);
  }

  $$last_ref = $msg;

  if (not ref $arg->{how}) {
    $self->last_msgs->{ $arg->{who} }->{ $arg->{how} } = $arg->{what};
  }

  # Genericize this: -- rjbs, 2014-06-19
  $msg = 'chill for 60 minutes' if lc $msg eq 'zzz';

  my ($cmd, $rest) = split ' ', $msg, 2;

  # First pass before stripping things down to alnum.
  $cmd = $ALIAS{$cmd} if $ALIAS{$cmd};

  $cmd =~ tr/[A-Za-z0-9]//dc;
  $cmd = lc $cmd;

  # Second pass for alnum aliases.
  $cmd = $ALIAS{$cmd} if $ALIAS{$cmd};

  my $method = "SAID_$cmd";
  $self->info("looking to call ->$method(" . ($rest // '') . ")");

  my %public = map {; $_ => 1 } qw(
    mute
    page task remind alerts ack maint oncall plusplus
  );

  return -1 unless $self->can("SAID_$cmd");

  unless ($public{$cmd} or $arg->{who} eq $config->{master}) {
    return $self->reply("Only $config->{master} can do that.", $arg);
  }

  return $self->$method({ %$arg, what => $rest });
}

sub reply {
  my ($self, $reply, $arg) = @_;

  if ($arg->{how} eq 'sms') {
    $self->sms($arg->{where}[0], $reply);
  } elsif (ref $arg->{how} eq 'SCALAR') {
    ${ $arg->{how} } = $reply;
  } else {
    $self->privmsg($arg->{where}, "$arg->{who}: $reply");
  }
}

sub SAID_pose {
  my ($self, $arg) = @_;

  unless ($arg->{who} eq $config->{master}) {
    return -1;
  }

  my $what = $arg->{what};

  if ($what =~ s{\A\s*/me\s+}{}g) {
    # emote
  }

  $self->privmsg(
    $self->get_channels->[0],
    $what,
  );

  return;
}

sub SAID_showtime {
  my ($self, $arg) = @_;

  if ($self->has_chilltill and $self->chilltill > time) {
    if ($self->is_business_hours) {
      $self->reply("Okay, back to work!", $arg);
    } else {
      $self->reply("Back to normal business hours, then.", $arg);
    }
  } elsif ($self->is_business_hours) {
    $self->reply("I thought it was already showtime!", $arg);
  } else {
    $self->start_showtime;
    return $self->reply("Okay, business hours extended!", $arg);
  }

  $self->clear_chilltill;
  return;
}

sub SAID_shows {
  my ($self, $arg) = @_;
  return $self->SAID_chill({ %$arg, what => 'until tomorrow' })
    if $arg->{what} eq 'over';
  return -1;
}

has _date_parser => (
  is => 'ro',
  default => sub {
    DateTime::Format::Natural->new(
      prefer_future => 1,
      time_zone     => 'America/New_York',
    );
  },
);

sub  _parse_time_hunk {
  my ($self, $hunk) = @_;

  my ($prep, $rest) = split ' ', $hunk, 2;

  if ($prep eq 'for') {
    my $dur;
    $rest =~ s/^an?\s+/1 /;
    my $ok = eval { $dur = parse_duration($rest); 1 };
    return unless $ok;
    return time + $dur;
  }

  if ($prep eq 'until') {
    my $dt = eval { $self->_date_parser->parse_datetime($rest) };
    return unless $dt;
    return $dt->epoch;
  }

  return;
}

sub SAID_chill {
  my ($self, $arg) = @_;

  my $time = $self->_parse_time_hunk($arg->{what});
  return -1 unless defined $time;

  if ($time <= time) {
    $self->reply("That sounded like you want to chill until the past.", $arg);
    return;
  }

  $self->chilltill($time);
  $self->reply("Okay, no more nagging until " . localtime $time, $arg);
}

sub SAID_mute {
  my ($self, $arg) = @_;
  return -1 unless $arg->{what} =~ s/\A\s*alerts\s+//;

  my $time = $self->_parse_time_hunk($arg->{what});
  return -1 unless defined $time;

  $self->suppress_alerts_until($time);
  $self->reply("Okay, alerts won't be relayed until " . localtime $time, $arg);
}

sub SAID_remind {
  my ($self, $arg) = @_;

  my ($who, $prep, $dur_str, $rest) = $arg->{what} =~ qr/\A
    \s*
    (\S+)    # "me" or a nick
    \s+
    (in|at) # duration type
    \s+
    (.+?)    # duration
    :\s+     # the space is vital:  "at 15:15: eat pie"
    (.+)     # the reminder
    \z
  /x;

  unless (length $who) {
    warn("couldn't parse <<$arg->{what}>>");
    return -1;
  }

  $who = $self->resolve_name($who, $arg->{who});

  my $time;
  if ($prep eq 'in') {
    my $dur;
    $dur_str =~ s/^an?\s+/1 /;
    my $ok = eval { $dur = parse_duration($dur_str); 1 };
    return -1 unless $ok;
    $time = time + $dur;
  } elsif ($prep eq 'at') {
    my $dt = eval { $self->_date_parser->parse_datetime($dur_str) };
    return -1 unless $dt;
    $time = $dt->epoch;
  } else {
    return -1;
  }

  if ($time <= time) {
    $self->reply("That sounded like you want a reminder sent in the past.", $arg);
    return;
  }

  my $target = $who eq $arg->{who} ? 'you' : $who;

  $self->alarm_add(
    send_reminder => $time,
    { %$arg, who => $who },
    DateTime->now(time_zone => 'America/New_York'),
    $rest,
  );
  $self->reply("Okay, I'll remind $target at " . localtime $time, $arg);
}

event send_reminder => sub {
  my ($self, $reply_arg, $requested_time, $msg) = @_[OBJECT, ARG0..ARG2];
  $self->reply("Reminder from $requested_time: $msg", $reply_arg);
};

sub SAID_abort {
  my ($self, $arg) = @_;

  if ($arg->{what} eq 'timer') {
    my $ua = $self->lp_ua;
    my $res = $ua->get("$LP_BASE/my_timers");

    return $self->reply("Something went wrong", $arg) unless $res->is_success;

    my ($timer) = grep {; $_->{running} }
                  @{ $JSON->decode( $res->decoded_content ) };

    unless ($timer) {
      $self->reply("You don't have an active timer to abort.", $arg);
      return;
    }

    my $stop_res = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/stop");
    my $clr_res  = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/clear");

    if ($stop_res->is_success and $clr_res->is_success) {
      $self->clear_last_nag;
      $self->reply("Okay, I stopped and cleared your active timer.", $arg);
    } else {
      $self->reply("Something went wrong aborting your timer.", $arg);
    }
  } else {
    $self->reply("I didn't understand your abort request.", $arg);
  }
}

sub SAID_reset {
  my ($self, $arg) = @_;

  if ($arg->{what} eq 'timer') {
    my $ua = $self->lp_ua;
    my $res = $ua->get("$LP_BASE/my_timers");

    return $self->reply("Something went wrong", $arg) unless $res->is_success;

    my ($timer) = grep {; $_->{running} }
                  @{ $JSON->decode( $res->decoded_content ) };

    unless ($timer) {
      $self->reply("You don't have an active timer to abort.", $arg);
      return;
    }

    my $clr_res  = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/clear");

    if ($clr_res->is_success) {
      $self->clear_last_nag;
      $self->reply("Okay, I cleared your active timer but left it running.", $arg);
    } else {
      $self->reply("Something went wrong resetting your timer.", $arg);
    }
  } else {
    $self->reply("I didn't understand your reset request.", $arg);
  }
}

sub SAID_commit {
  my ($self, $arg) = @_;

  my $comment = $arg->{what};
  my $meta    = $comment =~ s/\s+(DONE|STOP)(?:[.!]+)?\z//;
  my $done    = $1 && $1 eq 'DONE';
  my $stop    = $1 && ($done || $1 eq 'STOP');

  my $timer = $self->current_timer;

  return $self->reply("You don't seem to have a running timer.", $arg)
    unless $timer && ref $timer; # XXX <-- stupid return type

  my $task_res = $self->lp_ua->get("$LP_BASE/tasks/$timer->{item_id}");

  my $activity_id;
  unless ($task_res->is_success) {
    return $self->reply("I couldn't log the work because I couldn't find the current task's activity id.", $arg);
  }

  my $task = $JSON->decode($task_res->decoded_content);
  $activity_id = $task->{activity_id};

  unless ($activity_id) {
    return $self->reply("I couldn't log the work because the task doesn't have a defined activity.", $arg);
  }

  my $content = $JSON->encode({
    is_done => $done ? \1 : \0,
    comment => $comment,
    restart => $stop ? \0 : \1,
    activity_id => $activity_id,
  });

  my $commit_res = $self->lp_ua->post(
    "$LP_BASE/tasks/$timer->{item_id}/timer/commit",
    Content => $content,
    Content_Type => 'application/json',
  );

  unless ($commit_res->is_success) {
    warn $commit_res->as_string;
    return $self->reply("I couldn't commit your work, sorry.", $arg);
  }

  $self->clear_last_nag;
  my $also = $done ? ' and marked the task done'
           : $stop ? ' and stopped the timer'
           :         '';

  my $time = concise( duration( $timer->{running_time} * 3600 ) );
  $self->reply("Okay, I've committed $time of work$also.", $arg);
}

sub SAID_pause {
  my ($self, $arg) = @_;

  if ($arg->{what} eq 'timer') {
    my $ua = $self->lp_ua;
    my $res = $ua->get("$LP_BASE/my_timers");

    return $self->reply("Something went wrong", $arg) unless $res->is_success;

    my ($timer) = grep {; $_->{running} }
                  @{ $JSON->decode( $res->decoded_content ) };

    my $stop_res = $ua->post("$LP_BASE/tasks/$timer->{item_id}/timer/stop");
    unless ($stop_res->is_success) {
      return $self->reply("I couldn't pause your active timer.", $arg);
    }

    $self->clear_last_nag;
    $self->reply("Okay, I paused your active timer.", $arg);
  } else {
    $self->reply("I didn't understand your pause request.", $arg);
  }
}

has lp_ua => (
  is => 'ro',
  lazy    => 1,
  clearer => '_clear_lp_ua',
  default => sub {
    my $ua = LWP::UserAgent::POE->new(keep_alive => 1);
    my $token = $config->{lp_token};

    $ua->default_header('Authorization' => "$token");

    return $ua;
  },
);

has circ_ua => (
  is => 'ro',
  lazy    => 1,
  clearer => '_clear_circ_ua',
  default => sub {
    my $ua = LWP::UserAgent::POE->new(keep_alive => 1);
    my $token = $config->{circonus_token};

    $ua->default_header('X-Circonus-App-Name' => 'Synergy');
    $ua->default_header('X-Circonus-Auth-Token' => $token);
    $ua->default_header('Accept' => "application/json");

    return $ua;
  },
);

sub SAID_status {
  my ($self, $arg) = @_;

  my $ua = $self->lp_ua;
  my $res = $ua->get("$LP_BASE/my_timers");

  unless ($res->is_success) {
    $self->reply("I couldn't get your timer.", $arg);
    warn $res->as_string;
    return;
  }

  my @timers = grep {; $_->{running} }
               @{ $JSON->decode( $res->decoded_content ) };

  unless (@timers) {
    my $nag = $self->last_relevant_nag;
    my $msg;
    if (! $nag) {
      $msg = "You don't have a running timer.";
    } elsif ($nag->{level} == 0) {
      $msg = "Like I said, you don't have a running timer.";
    } else {
      $msg = "Like I keep telling you, you don't have a running timer!";
    }

    return $self->reply($msg, $arg);
  }

  if (@timers > 1) {
    $self->reply(
      "Woah.  LiquidPlanner says you have more than one active timer!",
      $arg,
    );
  }

  my $timer = $timers[0];
  my $time = concise( duration( $timer->{running_time} * 3600 ) );
  my $task_res = $ua->get("$LP_BASE/tasks/$timer->{item_id}");

  my $name = $task_res->is_success
           ? $JSON->decode($task_res->decoded_content)->{name}
           : '??';

  my $url = sprintf "https://app.liquidplanner.com/space/%s/projects/show/%s",
    $config->{workspace},
    $timer->{item_id};

  $self->reply(
    "Your timer has been running for $time, work on: $name <$url>",
    $arg,
  );
}

sub SAID_oncall {
  my ($self, $arg) = @_;

  my ($flag, @users) = split / /, $arg->{what};
  s/,$//g for @users;

  my $contact_group = $self->get_oncall_list;

  my @to_reply;

  if ($flag) {
    my @errors = $self->_do_oncall_update($arg->{who}, $contact_group, $flag, \@users);
    $self->reply($_, $arg) for @errors;
    return if @errors;
    push @to_reply, "Okay, oncall group updated!";
  }

  my $oncall = $self->_format_oncall_group($contact_group);
  $self->reply(join(q{  }, @to_reply, "Now on call: $oncall"), $arg);
}

sub _format_oncall_group {
  my ($self, $group) = @_;

  # Do we want to show externals here, too, just in case? -- rjbs, 2014-06-09
  my @current = @{ $group->{users} };

  my %user;
  foreach my $contact (@current) {
    my ($id) = $contact->{user} =~ m{/user/([0-9]+)\z};
    my $username = $self->username_for_circ_id($id) // "#$id";
    $user{$username}{$contact->{method}} = 1;
  }

  my $str = join q{; },
            map {; sprintf '%s (%s)', $_, (join q{, }, sort keys %{ $user{$_} }) }
            sort keys %user;

  return $str;
}

sub _do_oncall_update {
  my ($self, $who_said, $contact_group, $flag, $users) = @_;

  my @current;

  my $ua = $self->circ_ua;

  unless ($flag eq "set") {
    foreach my $now (@{ $contact_group->{users} }){
      my ($foo, $user, $id) = split('/', $now->{user});
      push @current, $id;
    }
  }

  foreach my $who (@$users) {
    my $user = $self->resolve_name($who, $who_said);
    if ( my $id = $config->{circ_members}{$user} ) {
      my $method = "$flag\_oncall";

      return "I don't understand your command '$flag'"
        unless $self->can($method);

      $self->$method(\@current, $id);
    } else {
      return "$who is unknown. Try using another name, or use their contact ID number."
    }
  }

  $self->update_oncall_list($contact_group->{external}, @current);

  # We (presumably) updated the on-call list, so update the one we will print.
  %$contact_group = %{ $self->get_oncall_list };

  return;
}

sub get_oncall_list {
  my ($self) = @_;
  my $ua = $self->circ_ua;
  my $res = $ua->get("$CIRC_BASE/contact_group/$config->{circonus_oncall_group}");
  my $json = $res->decoded_content;
  my $contacts = $JSON->decode($json);
  return $contacts->{contacts};
}

sub update_oncall_list {
  my ($self, $external, @current) = @_;

  my $ua = $self->circ_ua;
  my @to_send;
  foreach my $person (@current) {
    my $res = $ua->get("$CIRC_BASE/user/$person");
    my $json = $res->decoded_content;
    my $contact_info = $JSON->decode($json);
    push @to_send, (
      {
        '_contact_info' => $contact_info->{contact_info}->{sms},
        'user' => $contact_info->{_cid},
        'method' => 'sms'
      },
      {
        '_contact_info' => $contact_info->{email},
        'user' => $contact_info->{_cid},
        'method' => 'email'
      }
    );
  }

  my $set_struct = $JSON->encode({
    contacts => {
      users => \@to_send,
      external => $external,
    },
  });

  my $result = $ua->put(
    "$CIRC_BASE/contact_group/$config->{circonus_oncall_group}",
    Content => $set_struct,
  );
}

sub add_oncall {
  my ($self, $current, $id) = @_;
  push @$current, $id unless grep { $_ == $id } @$current;
}

sub remove_oncall {
  my ($self, $current, $id) = @_;

  @$current = grep {; $_ != $id } @$current;
}

sub set_oncall {
  my ($self, $current, $id) = @_;

  push @$current, $id;
}

sub SAID_plusplus {
  my ($self, $arg) = @_;

  if (! length $arg->{what}) {
    return $self->reply("Thanks, but I'm only as awesome as my creators.", $arg);
  }

  return $self->SAID_task({
    %$arg,
    what => "for $arg->{who}: $arg->{what}",
  });
}

sub SAID_alerts {
  my ($self, $arg) = @_;
  my $ua = $self->circ_ua;

  my $res = $ua->get("$CIRC_BASE/alert");
  my $json = $res->decoded_content;
  my $alerts = $JSON->decode($json);

  return $self->reply("Everything's okay!", $arg) unless @$alerts;

  for my $event (@$alerts) {
    my $response = sprintf '%s %s %s',
      $event->{_cid}, $event->{_check_name}, $event->{_alert_url};
    $self->reply($response, $arg);
  }
}

sub SAID_ack {
  my ($self, $arg) = @_;

  return $self->reply("ack in format '<alert id> for <time>'")
    unless my ($alert_id, $dur_str) = $arg->{what} =~ /\A(\S+)(?:\s+for\s+(.+?))?\s*\z/;

  $dur_str = '15m' unless $dur_str;

  if ($alert_id eq '*') {
    # We'll do multi-ack.
  } elsif ($alert_id !~ /\A[0-9]+\z/) {
    return $self->reply(
      qq{"$alert_id" doesn't look like a cromulent alert id.  } .
      qq{They're just numbers!},
      $arg
    );
  }

  my $dur;
  my $ok = eval { $dur = parse_duration($dur_str); 1 };

  return $self->reply("I didn't understand how long you wanted to ack it!", $arg)
    unless $ok;

  my $min = int($dur / 60);

  return $self->reply("You can't ack something for less than a minute!", $arg)
    unless $min;

  my $long = concise(duration($dur - $dur % 60));

  if ($alert_id eq '*') {
    my $stash = $self->recent_alerts;
    unless (keys %$stash) {
      return $self->reply("There are no recent alerts to ack!", $arg);
    }

    my @acked;
    my @failed;

    for my $alert_id (keys %$stash) {
      my $alert = $stash->{$alert_id};
      my $desc = sprintf "(%s on %s)", $alert->{metric_name}, $alert->{host};
      if ($self->_ack_alert_for($alert_id, $min)) {
        push @acked, $desc;
      } else {
        push @failed, $desc;
      }
    }

    if (@acked) {
      $self->reply("Acked for $long: " . join(q{, }, @acked), $arg);
    }
    if (@failed) {
      $self->reply("Failed to ack: " . join(q{, }, @failed), $arg);
    }

    return;
  } else {
    my $acked = $self->_ack_alert_for($alert_id, $min);

    if ($acked) {
      return $self->reply("Alert $alert_id acked for $long.", $arg);
    } else {
      return $self->reply(
        "Alert couldn't be acked.  Maybe check 'alerts'?",
        $arg,
      );
    }
  }
}

sub _ack_alert_for {
  my ($self, $alert_id, $min) = @_;

  my $ua = $self->circ_ua;
  my $check = $ua->get("$CIRC_BASE/alert/$alert_id");

  return unless $check->is_success;

  my $content = $JSON->encode({
    acknowledged_until => $min . 'm',
    alert              => "/alert/$alert_id",
  });

  my $res = $ua->post(
    "$CIRC_BASE/acknowledgement",
    Content => $content
  );

  return $res->is_success;
}

sub SAID_maint {
  my ($self, $arg) = @_;

  return -1
    unless my ($target, $dur_str) = $arg->{what} =~ /\A(\S+)(?:\s+for\s+(.+?))?\s*\z/;

  $target =~ s{^http://}{}; # Slack, sometimes you suck. -- rjbs, 2015-04-06

  $dur_str = '15m' unless $dur_str;

  my $is_host;

  if ($target eq '*') {
    # We'll do multi-ack.
    return $self->reply("Multi-maint not yet implemented", $arg);
  } if ($target =~ /\A[0-9]+\z/) {
    $is_host = 0;
  } elsif ($target =~ /\A(?:[-0-9a-z]+\.)*[-0-9a-z]+\z/) {
    $is_host = 1;
  } else {
    return $self->reply("I don't know what kind of maint $target is.", $arg);
  }

  my $dur;
  my $ok = eval { $dur = parse_duration($dur_str); 1 };

  return $self->reply("I didn't understand how long you wanted to ack it!", $arg)
    unless $ok;

  my $min = int($dur / 60);

  return $self->reply("You can't maint something for less than a minute!", $arg)
    unless $min;

  my $long = concise(duration($dur - $dur % 60));

  if ($is_host) {
    if ($self->_maint_host_for($target, $min)) {
      return $self->reply("Maintenance for host $target begun!", $arg)
    }

    return $self->reply("Sorry, I couldn't start a maintenance window for host $target!", $arg)
  }

  if ($self->_maint_alert_for($target, $min)) {
    return $self->reply("Maintenance for alert $target begun!", $arg)
  }

  return $self->reply("Sorry, I couldn't start a maintenance window for alert $target!", $arg)
}

sub _maint_alert_for {
  my ($self, $alert_id, $min) = @_;

  my $ua = $self->circ_ua;
  my $check = $ua->get("$CIRC_BASE/alert/$alert_id");

  return unless $check->is_success;

  my $alert = $JSON->decode( $check->decoded_content );
  my $check_path = $alert->{_check};

  my $content = $JSON->encode({
    item       => $check_path,
    severities => [ 1..5 ],
    start      => time,
    stop       => time  +  $min * 60,
    notes      => "requested via Synergy",
    type       => 'check',
  });

  my $res = $ua->post(
    "$CIRC_BASE/maintenance",
    Content => $content
  );

  warn "MAINT FAIL: " . $res->as_string unless $res->is_success;

  return $res->is_success;
}

sub _maint_host_for {
  my ($self, $host, $min) = @_;

  my $ua = $self->circ_ua;

  my $content = $JSON->encode({
    item       => "$host",
    severities => [ 1..5 ],
    start      => time,
    stop       => time  +  $min * 60,
    notes      => "requested via Synergy",
    type       => 'host',
  });

  my $res = $ua->post(
    "$CIRC_BASE/maintenance",
    Content => $content
  );

  warn "MAINT FAIL: " . $res->as_string unless $res->is_success;

  return $res->is_success;
}

sub SAID_task {
  my ($self, $arg) = @_;

  # because of "new task for...";
  my $what = $arg->{what} =~ s/\Atask\s+//r;

  my ($target, $name) = $what =~ /\s*for\s+(.+?):\s+(.+)\z/;

  my @target_names = split /(?:\s*,\s*|\s+and\s+)/, $target;
  my (@owner_ids, @owner_names, @unknown);
  my %seen;
  for my $name (@target_names) {
    my $target = $self->resolve_name($name, $arg->{who});
    next if $seen{$target}++;

    my $owner_id = $config->{lp_members}{$target};
    # Sadly, the following line is not valid:
    # push(($owner_id ? @owner_ids : @unknown), $owner_id);
    if ($owner_id) {
      push @owner_names, $target;
      push @owner_ids, $owner_id;
    } else {
      push @unknown, $owner_id;
    }
  }

  if (@unknown) {
    my $str = @unknown == 1 ? "$unknown[0] is"
            : @unknown == 2 ? "$unknown[0] or $unknown[1] are"
            : join(q{, }, @unknown[0 .. $#unknown-1], "or $unknown[-1] are");
    return $self->reply("I don't know who $str.", $arg);
  }

  my ($urgent, $start);
  if ($name =~ s/\s*\(([!>]+)\)\s*\z//) {
    my ($code) = $1;
    $urgent = $code =~ /!/;
    $start  = $code =~ />/;
  }

  my $where = ref $arg->{where} ? $arg->{where}[0] : $arg->{where};
  my $payload = { task => {
    name     => $name,
    ($urgent ? (parent_id => $config->{lp_urgent}) : ()),
    assignments => [ map {; { person_id => $_ } } @owner_ids ],
    description => "created by " . $self->get_nickname . " on $where "
                .  "on behalf of $arg->{who}",
  } };

  my $res = $self->lp_ua->post(
    "$LP_BASE/tasks",
    Content_Type => 'application/json',
    Content => $JSON->encode($payload),
  );

  unless ($res->is_success) {
    warn ">>" . $res->decoded_content . "<<";
    warn $res->as_string;
    return $self->reply(
      "Sorry, something went wrong when I tried to make that task.",
      $arg,
    );
  }

  my $task_id = $JSON->decode($res->decoded_content)->{id};

  my $rcpt = join q{ and }, @owner_names;
  $self->reply(
    sprintf(
      "Task for $rcpt created: https://app.liquidplanner.com/space/%s/projects/show/%s",
      $config->{workspace},
      $task_id,
    ),
    $arg,
  );

  if ($start) {
    my $res = $self->lp_ua->post(
      "$LP_BASE/tasks/$task_id/timer/start",
      Content_Type => 'application/json',
      Content => $JSON->encode($payload),
    );

    if ($res->is_success) {
      $self->reply("Timer for new task has been begun.", $arg);
    } else {
      $self->reply("There was a problem starting your new task's timer.", $arg);
    }
  }

}

sub SAID_page {
  my ($self, $arg) = @_;
  $arg->{what} =~ s/\A\s+//;
  $arg->{what} =~ s/\s+\z//;

  if ($arg->{what} =~ /\A(\w+)[.?!]*\z/) {
    my $who   = $self->resolve_name("$1", $arg->{who});
    my $phone = $self->phone_for_username($who);

    unless ($phone) {
      return $self->reply("I don't have a number for $who.", $arg);
    }

    $self->sms($phone, "$arg->{who} just paged you on @{ $arg->{where} }");
    $self->reply("Okay, I sent a page.", $arg);
    return;
  }

  my ($who, $rest) = split /\s*:\s*/, $arg->{what}, 2;
  $who = $self->resolve_name($who, $arg->{who});

  unless ($arg->{what} and $arg->{what} =~ /\S/) {
    return $self->reply(
      "It goes:  <<page whoever>> or <<page whoever: message>>",
      $arg,
    );
  }

  my $phone = $self->phone_for_username($who);
  unless ($phone) {
    return $self->reply("I don't have a number for $who.", $arg);
  }

  $self->sms(
    $phone,
    "$arg->{who} just paged you on @{ $arg->{where} }: $rest",
  );
  $self->reply("Okay, I sent a page.", $arg);
  return;
}

sub SAID_whats {
  my ($self, $arg) = @_;
  return $self->SAID_what({ %$arg, what => "is $arg->{what}" });
}

sub _fmt_ph {
  my ($self, $ph) = @_;

  my ($c, $ac, $ex, $rest) = $ph =~ m{
    \A
    ([0-9])? ([0-9]{3}) ([0-9]{3}) ([0-9]{4})
    \z
  }x;

  $c //= 1;

  return "+$c $ac $ex-$rest";
}

sub SAID_who {
  my ($self, $arg) = @_;
  my $what = $arg->{what};
  $what =~ s/\s*\?*\z//;
  return -1 unless $what =~ s/\Ais\s+//;

  my $who = $self->resolve_name($what, $arg->{who});
  return $self->reply(qq!I don't know who "$what" is.!, $arg) if ! $who;

  my $rn = $config->{realnames}{$who} // '';
  $rn &&= " ($rn)";

  if ($what eq $arg->{who}) {
    return $self->reply(qq{"$who" is "$who$rn."  Obviously.}, $arg);
  }

  return $self->reply(qq["$what" is an alias for $who$rn.], $arg);
}

sub SAID_what {
  my ($self, $arg) = @_;
  my $what = $arg->{what};
  $what =~ s/\s*\?*\z//;
  return -1 unless $what =~ s/\Ais //;

  if ($what =~ /\Ayour (?:phone )?number\z/) {
    my $num = $self->_fmt_ph($config->{twilio_from});
    return $self->reply("You can text me at $num.", $arg);
  }

  if ($what =~ /\A(\S+?)(?:'s)? (?:phone )?number\z/) {
    my $who   = $self->resolve_name("$1", $arg->{who});
    my $phone = $self->phone_for_username($who);

    return $self->reply("I don't have a number on file for $who.", $arg)
      unless $phone;

    my $num = $self->_fmt_ph($phone);
    return $self->reply("You can reach $who at $num.", $arg);
  }

  return -1;
}

sub SAID_reload {
  my ($self, $arg) = @_;

  return -1 unless $arg->{what} eq 'config';

  $config = YAML::XS::LoadFile($ENV{SYNERGY_CONFIG});

  # All of these are potentially invalidated by a config reload. -- rjbs,
  # 2014-06-10
  $self->_clear_phone_book;
  $self->_clear_reverse_phone_book;
  $self->_clear_circ_book;
  $self->_clear_reverse_circ_book;
  $self->_clear_lp_ua;
  $self->_clear_circ_ua;

  return $self->reply("Configuration reloaded.", $arg);
}

sub SAID_compose {
  my ($self, $arg) = @_;

  return -1 unless lc $arg->{what} =~ /\Aa haiku\s*(?:for (\S+)\s*)?\z/;
  my $for = $1;

  my $haiku;
  my $ok = eval { require Haiku; $haiku = join q{ / }, Haiku::haiku(); 1 };

  return $self->reply("The muse is not with me.", $arg) unless $ok;

  if (my $for = $self->resolve_name($for, $arg->{who})) {
    return $self->reply("I don't know two to reach $for.", $arg)
      unless my $ph = $self->phone_for_username($config->{master});

    $self->sms($ph, "A haiku from $arg->{who}: $haiku");
    return $self->reply("Poem dispatched.", $arg);
  }

  return $self->reply($haiku, $arg);
}

my %HELP = (
  abort    => "abort timer -- stop and clear the timer (master user only)",
  ack      => "ack ALERTID [for DURATION] -- acknowledge an alert",
  alerts   => "alerts -- list active Circonus alerts",
  announce => "announce MESSAGE -- say something on IRC, for use via SMS",
  chill    => "chill [until TIME | for DURATION] -- stop nagging for a while (master user only)",
  oncall   => "oncall -- list on call users; also, (oncall add SOMEBODY, oncall remove SOMEBODY, oncall set SOMEBODY...)",
  page     => "page SOMEBODY: message -- send an SMS to a user",
  pause    => "pause timer -- pause the current timer (master user only)",
  remind   => "remind SOMEBODY [at TIME | in DURATION] -- set up a reminder",
  reset    => "reset timer -- clear the timer, leave it running (master user only)",
  showtime => "showtime -- stop chilling, start nagging",
  status   => "status -- show timer status (master user only)",
  task     => "task for SOMEBODY: TASK -- make a new task in Liquid Planner",
  what     => "what's SOMEBODY's number -- get a user's phone number",
);

sub SAID_help {
  my ($self, $arg) = @_;

  unless (length $arg->{what}) {
    return $self->reply("known commands: " . (join q{, }, sort keys %HELP), $arg);
  }

  my $help = $HELP{$arg->{what}};

  return $self->reply("unknown command", $arg) unless $help;
  return $self->reply($help, $arg);
}

sub BUILD {
  my ($self) = @_;

  $self->delay(nag => 60, qw(foo bar baz));
}

__PACKAGE__->run;
